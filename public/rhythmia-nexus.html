<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RHYTHMIA NEXUS</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Zen+Kaku+Gothic+New:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --neon-pink: #FF6B9D;
            --neon-cyan: #4ECDC4;
            --neon-purple: #A29BFE;
            --neon-gold: #FFD700;
            --neon-orange: #FF6B35;
            --dark-bg: #0a0a12;
            --darker-bg: #050508;
        }

        body {
            font-family: 'Zen Kaku Gothic New', sans-serif;
            background: var(--dark-bg);
            min-height: 100vh;
            overflow-x: hidden;
            color: #fff;
        }

        /* Animated background */
        .bg-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(78, 205, 196, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(78, 205, 196, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(50px); }
        }

        .bg-glow {
            position: fixed;
            width: 600px;
            height: 600px;
            border-radius: 50%;
            filter: blur(150px);
            opacity: 0.3;
            pointer-events: none;
            z-index: 0;
        }

        .glow-1 {
            top: -200px;
            left: -200px;
            background: var(--neon-pink);
            animation: glowPulse 8s ease-in-out infinite;
        }

        .glow-2 {
            bottom: -200px;
            right: -200px;
            background: var(--neon-cyan);
            animation: glowPulse 8s ease-in-out infinite 4s;
        }

        .glow-3 {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--neon-purple);
            animation: glowPulse 8s ease-in-out infinite 2s;
            opacity: 0.15;
        }

        @keyframes glowPulse {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.2); }
        }

        /* Main container */
        .container {
            position: relative;
            z-index: 1;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 900;
            letter-spacing: 0.3em;
            background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 107, 157, 0.5);
        }

        .status-bar {
            display: flex;
            gap: 20px;
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: statusPulse 2s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main content */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
        }

        .hero-text {
            text-align: center;
            margin-bottom: 60px;
        }

        .hero-text h1 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: 900;
            letter-spacing: 0.2em;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.7) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(255,107,157,0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(78,205,196,0.8)); }
        }

        .hero-text p {
            font-size: 1.1rem;
            opacity: 0.6;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }

        /* Server selection */
        .server-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            width: 100%;
            max-width: 1200px;
        }

        .server-card {
            position: relative;
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 35px 25px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .server-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--card-color) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.4s;
        }

        .server-card:hover::before {
            opacity: 0.1;
        }

        .server-card:hover {
            transform: translateY(-10px) scale(1.02);
            border-color: var(--card-color);
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.5),
                0 0 40px var(--card-color-dim);
        }

        .server-card.vanilla {
            --card-color: var(--neon-cyan);
            --card-color-dim: rgba(78, 205, 196, 0.3);
        }

        .server-card.modded {
            --card-color: var(--neon-pink);
            --card-color-dim: rgba(255, 107, 157, 0.3);
        }

        .server-card.multiplayer {
            --card-color: var(--neon-gold);
            --card-color-dim: rgba(255, 215, 0, 0.3);
        }

        .card-icon {
            font-size: 3.5rem;
            margin-bottom: 15px;
            display: block;
        }

        .card-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 6px 14px;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            border-radius: 20px;
            background: var(--card-color);
            color: var(--darker-bg);
        }

        .card-badge.new {
            background: linear-gradient(135deg, #FF6B35, #FFD700);
            animation: badgePulse 2s ease-in-out infinite;
        }

        @keyframes badgePulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        .card-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--card-color);
        }

        .card-subtitle {
            font-size: 0.85rem;
            opacity: 0.5;
            margin-bottom: 15px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        .card-description {
            font-size: 0.9rem;
            line-height: 1.7;
            opacity: 0.7;
            margin-bottom: 20px;
        }

        .card-features {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .feature-tag {
            padding: 5px 10px;
            font-size: 0.7rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 15px;
            opacity: 0.8;
        }

        .card-stats {
            display: flex;
            gap: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--card-color);
        }

        .stat-label {
            font-size: 0.65rem;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .play-button {
            position: relative;
            width: 100%;
            padding: 14px;
            margin-top: 15px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: var(--darker-bg);
            background: linear-gradient(135deg, var(--card-color), var(--card-color));
            border: none;
            border-radius: 12px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s;
        }

        .play-button:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px var(--card-color-dim);
        }

        .play-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .play-button:hover::after {
            left: 100%;
        }

        /* Game iframe container */
        .game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--darker-bg);
            z-index: 100;
            display: none;
            flex-direction: column;
        }

        .game-container.active {
            display: flex;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: rgba(0,0,0,0.8);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .game-title {
            font-family: 'Orbitron', monospace;
            font-size: 1rem;
            letter-spacing: 0.2em;
        }

        .back-button {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            letter-spacing: 0.1em;
            color: #fff;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .back-button:hover {
            background: rgba(255,255,255,0.2);
            border-color: var(--neon-cyan);
        }

        .game-frame {
            flex: 1;
            border: none;
            width: 100%;
        }

        /* Footer */
        footer {
            padding: 30px 40px;
            text-align: center;
            font-size: 0.8rem;
            opacity: 0.4;
            letter-spacing: 0.2em;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header {
                padding: 20px;
                flex-direction: column;
                gap: 15px;
            }

            .server-grid {
                grid-template-columns: 1fr;
                padding: 0 10px;
            }

            .hero-text h1 {
                letter-spacing: 0.1em;
            }
        }

        /* Loading animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--darker-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255,255,255,0.1);
            border-top-color: var(--neon-cyan);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
            letter-spacing: 0.3em;
            opacity: 0.7;
        }

        /* Online indicator */
        .online-count {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--neon-gold);
            margin-top: 8px;
        }

        .online-dot {
            width: 6px;
            height: 6px;
            background: var(--neon-gold);
            border-radius: 50%;
            animation: onlinePulse 1.5s ease-in-out infinite;
        }

        @keyframes onlinePulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 5px var(--neon-gold); }
            50% { opacity: 0.5; box-shadow: 0 0 15px var(--neon-gold); }
        }
    </style>
</head>
<body>
    <!-- Background effects -->
    <div class="bg-grid"></div>
    <div class="bg-glow glow-1"></div>
    <div class="bg-glow glow-2"></div>
    <div class="bg-glow glow-3"></div>

    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loader"></div>
        <div class="loading-text">INITIALIZING...</div>
    </div>

    <div class="container">
        <header>
            <div class="logo">RHYTHMIA</div>
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-dot"></span>
                    <span>„Çµ„Éº„Éê„ÉºÊé•Á∂ö‰∏≠</span>
                </div>
                <div class="status-item">
                    <span>v2.5.0</span>
                </div>
            </div>
        </header>

        <main>
            <div class="hero-text">
                <h1>SELECT SERVER</h1>
                <p>„Çµ„Éº„Éê„Éº„ÇíÈÅ∏Êäû„Åó„Å¶„Éó„É¨„Ç§ÈñãÂßã</p>
            </div>

            <div class="server-grid">
                <!-- Vanilla Server -->
                <div class="server-card vanilla" onclick="launchGame('vanilla')">
                    <span class="card-badge">OFFICIAL</span>
                    <span class="card-icon">üéÆ</span>
                    <h2 class="card-title">VANILLA</h2>
                    <p class="card-subtitle">Original Experience</p>
                    <p class="card-description">
                        „Ç™„É™„Ç∏„Éä„É´„ÅÆRHYTHMIA‰ΩìÈ®ì„ÄÇ„É™„Ç∫„É†„Å´‰πó„Å£„Å¶„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ©ç„Åø„ÄÅ„ÉØ„Éº„É´„Éâ„ÇíÊîªÁï•„Åó„Çà„ÅÜ„ÄÇÁ¥îÁ≤ã„Å™„Ç≤„Éº„É†„Éó„É¨„Ç§„ÇíÊ•Ω„Åó„ÇÅ„Åæ„Åô„ÄÇ
                    </p>
                    <div class="card-features">
                        <span class="feature-tag">üéµ 5„ÉØ„Éº„É´„Éâ</span>
                        <span class="feature-tag">‚ö° „É™„Ç∫„É†„Ç∑„Çπ„ÉÜ„É†</span>
                        <span class="feature-tag">üé® „Ç™„É™„Ç∏„Éä„É´</span>
                    </div>
                    <div class="card-stats">
                        <div class="stat">
                            <div class="stat-value">100</div>
                            <div class="stat-label">BPM Start</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">160</div>
                            <div class="stat-label">BPM Max</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">‚àû</div>
                            <div class="stat-label">„É¨„Éô„É´</div>
                        </div>
                    </div>
                    <button class="play-button">‚ñ∂ PLAY NOW</button>
                </div>

                <!-- Multiplayer Server -->
                <div class="server-card multiplayer" onclick="launchGame('multiplayer')">
                    <span class="card-badge new">üî• NEW</span>
                    <span class="card-icon">‚öîÔ∏è</span>
                    <h2 class="card-title">BATTLE ARENA</h2>
                    <p class="card-subtitle">Multiplayer Mode</p>
                    <p class="card-description">
                        „É™„Ç¢„É´„Çø„Ç§„É†ÂØæÊà¶„É¢„Éº„ÉâÔºÅ„É©„Ç§„É≥Ê∂àÂéª„ÅßÁõ∏Êâã„Å´„Ç¨„Éô„Éº„Ç∏„ÇíÈÄÅ„ÇäËæº„ÇÅ„ÄÇÊúÄÂæå„Åæ„ÅßÁîü„ÅçÊÆã„Å£„ÅüËÄÖ„ÅåÂãùËÄÖ„Å†„ÄÇ
                    </p>
                    <div class="card-features">
                        <span class="feature-tag">üë• 2PÂØæÊà¶</span>
                        <span class="feature-tag">ü§ñ AIÂØæÊà¶</span>
                        <span class="feature-tag">üí• „Ç¨„Éô„Éº„Ç∏</span>
                        <span class="feature-tag">üèÜ „É©„É≥„Ç≠„É≥„Ç∞</span>
                    </div>
                    <div class="card-stats">
                        <div class="stat">
                            <div class="stat-value">VS</div>
                            <div class="stat-label">Mode</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">1v1</div>
                            <div class="stat-label">Battle</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">LIVE</div>
                            <div class="stat-label">Status</div>
                        </div>
                    </div>
                    <div class="online-count">
                        <span class="online-dot"></span>
                        <span id="onlineCount">127 players online</span>
                    </div>
                    <button class="play-button">‚öîÔ∏è BATTLE NOW</button>
                </div>

                <!-- Modded Server -->
                <div class="server-card modded" onclick="launchGame('modded')">
                    <span class="card-badge">MODDED</span>
                    <span class="card-icon">‚ú®</span>
                    <h2 class="card-title">LIFE JOURNEY</h2>
                    <p class="card-subtitle">Zen Experience</p>
                    <p class="card-description">
                        ‰∫∫Áîü„ÅÆÊóÖ„Çí‰ΩìÈ®ì„Åô„Çã„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Ç¢„Éº„Éà„ÄÇË™ïÁîü„Åã„ÇâÁ∂ôÊâø„Åæ„Åß„ÄÅ7„Å§„ÅÆÁ´†„ÇíÈÄö„Åò„Å¶‰∫∫Áîü„ÅÆÊÑèÂë≥„ÇíÊé¢Ê±Ç„Åó„Åæ„Åô„ÄÇ
                    </p>
                    <div class="card-features">
                        <span class="feature-tag">üåÖ 7„ÉÅ„É£„Éó„Çø„Éº</span>
                        <span class="feature-tag">üé® „Éì„Ç∏„É•„Ç¢„É´„Ç¢„Éº„Éà</span>
                        <span class="feature-tag">üìñ „Çπ„Éà„Éº„É™„Éº</span>
                    </div>
                    <div class="card-stats">
                        <div class="stat">
                            <div class="stat-value">7</div>
                            <div class="stat-label">Chapters</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">‚àû</div>
                            <div class="stat-label">„É™„Éó„É¨„Ç§</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">ZEN</div>
                            <div class="stat-label">Mode</div>
                        </div>
                    </div>
                    <button class="play-button">‚ñ∂ EXPERIENCE</button>
                </div>
            </div>
        </main>

        <footer>
            RHYTHMIA NEXUS ¬© 2025 ‚Äî PLAY YOUR RHYTHM
        </footer>
    </div>

    <!-- Game Container for Vanilla -->
    <div class="game-container" id="vanillaContainer">
        <div class="game-header">
            <span class="game-title">üéÆ RHYTHMIA ‚Äî VANILLA SERVER</span>
            <button class="back-button" onclick="closeGame('vanilla')">
                ‚Üê „É≠„Éì„Éº„Å´Êàª„Çã
            </button>
        </div>
        <iframe class="game-frame" id="vanillaFrame" srcdoc=""></iframe>
    </div>

    <!-- Game Container for Multiplayer -->
    <div class="game-container" id="multiplayerContainer">
        <div class="game-header">
            <span class="game-title">‚öîÔ∏è BATTLE ARENA ‚Äî MULTIPLAYER</span>
            <button class="back-button" onclick="closeGame('multiplayer')">
                ‚Üê „É≠„Éì„Éº„Å´Êàª„Çã
            </button>
        </div>
        <iframe class="game-frame" id="multiplayerFrame" srcdoc=""></iframe>
    </div>

    <!-- Game Container for Modded -->
    <div class="game-container" id="moddedContainer">
        <div class="game-header">
            <span class="game-title">‚ú® LIFE JOURNEY ‚Äî MOD SERVER</span>
            <button class="back-button" onclick="closeGame('modded')">
                ‚Üê „É≠„Éì„Éº„Å´Êàª„Çã
            </button>
        </div>
        <iframe class="game-frame" id="moddedFrame" srcdoc=""></iframe>
    </div>

    <script>
        // Loading animation
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }, 1500);
        });

        // Simulate online player count
        function updateOnlineCount() {
            const base = 120;
            const variance = Math.floor(Math.random() * 30) - 15;
            document.getElementById('onlineCount').textContent = (base + variance) + ' players online';
        }
        setInterval(updateOnlineCount, 5000);

        // Game content storage
        const gameContent = {
            vanilla: null,
            modded: null,
            multiplayer: null
        };

        // Vanilla game HTML (RHYTHMIA)
        gameContent.vanilla = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RHYTHMIA</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-user-select: none; }
        
        html, body { 
            height: 100%; 
            overflow: hidden; 
            touch-action: manipulation;
            font-family: system-ui, -apple-system, sans-serif;
        }
        
        body {
            background: #0a0a12;
            transition: background 0.5s;
        }

        .w0 { --c1: #FF6B9D; --c2: #C44569; --bg: #1a1025; }
        .w1 { --c1: #4ECDC4; --c2: #1A535C; --bg: #051620; }
        .w2 { --c1: #FFE66D; --c2: #F7B731; --bg: #1a1505; }
        .w3 { --c1: #FF6B6B; --c2: #C0392B; --bg: #1a0a0a; }
        .w4 { --c1: #A29BFE; --c2: #6C5CE7; --bg: #0a0a1a; }

        body { background: var(--bg); }

        #game {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
            gap: 10px;
        }

        #score-display {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 30px var(--c1);
            transition: transform 0.1s;
        }
        #score-display.pop { transform: scale(1.2); }

        #combo {
            font-size: clamp(1.5rem, 5vw, 2.5rem);
            font-weight: 700;
            color: var(--c1);
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #combo.show { opacity: 1; transform: scale(1); }
        #combo.big { transform: scale(1.5); color: #FFD700; }

        #game-area {
            position: relative;
            display: flex;
            gap: 10px;
            align-items: flex-start;
        }

        #board-wrap {
            position: relative;
            border: 3px solid var(--c1);
            border-radius: 8px;
            background: rgba(0,0,0,0.5);
            box-shadow: 0 0 30px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transition: box-shadow 0.1s, transform 0.1s;
            overflow: hidden;
        }
        #board-wrap.beat { 
            box-shadow: 0 0 50px var(--c1), 0 0 80px var(--c1), inset 0 0 30px rgba(0,0,0,0.5);
            transform: scale(1.02);
        }
        #board-wrap.shake {
            animation: shake 0.2s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        #board {
            display: grid;
            gap: 1px;
            position: relative;
        }

        .cell {
            width: clamp(16px, 4vw, 28px);
            height: clamp(16px, 4vw, 28px);
            background: rgba(255,255,255,0.03);
            border-radius: 2px;
            transition: all 0.1s;
        }
        .cell.filled {
            box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.3);
        }
        .cell.ghost {
            opacity: 0.3;
        }
        .cell.clearing {
            animation: clear 0.3s ease-out forwards;
        }
        @keyframes clear {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); background: white; }
            100% { transform: scale(0); opacity: 0; }
        }

        #active-piece {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            transition: transform 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }
        #active-piece.dropping {
            transition: transform 0.02s linear;
        }
        .piece-cell {
            position: absolute;
            border-radius: 2px;
            box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.3);
        }

        #next-wrap {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
        }
        #next-label {
            color: rgba(255,255,255,0.5);
            font-size: 0.7rem;
            text-align: center;
            margin-bottom: 5px;
        }
        #next {
            display: grid;
            gap: 1px;
        }
        .next-cell {
            width: clamp(12px, 3vw, 20px);
            height: clamp(12px, 3vw, 20px);
            border-radius: 2px;
        }

        #beat-bar {
            width: min(300px, 80vw);
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        #beat-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--c2), var(--c1));
            border-radius: 10px;
            transition: width 0.05s linear;
            box-shadow: 0 0 20px var(--c1);
        }
        #beat-target {
            position: absolute;
            right: 10%;
            top: 0;
            bottom: 0;
            width: 15%;
            background: rgba(255,215,0,0.3);
            border: 2px solid #FFD700;
            border-radius: 8px;
        }

        #judgment {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(2rem, 10vw, 5rem);
            font-weight: 900;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
        }
        #judgment.show {
            animation: judgePop 0.5s ease-out forwards;
        }
        @keyframes judgePop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(1); }
        }

        #controls {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            width: min(350px, 90vw);
        }
        .ctrl-btn {
            aspect-ratio: 1;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 12px;
            color: white;
            font-size: clamp(1.2rem, 4vw, 2rem);
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        .ctrl-btn:active {
            transform: scale(0.9);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        #title-screen {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            z-index: 200;
            gap: 30px;
        }
        #title-screen h1 {
            font-size: clamp(3rem, 12vw, 6rem);
            font-weight: 900;
            color: white;
            text-shadow: 0 0 30px var(--c1), 0 0 60px var(--c1);
        }
        #title-screen p {
            color: rgba(255,255,255,0.7);
            font-size: 1.2rem;
        }
        #start-btn {
            padding: 20px 60px;
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 30px var(--c1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px var(--c1);
        }

        #world-display {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 0.9rem;
            opacity: 0.7;
        }

        #enemy-bar {
            width: min(250px, 70vw);
            height: 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        #enemy-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF4444, #FF8888);
            transition: width 0.3s;
            box-shadow: 0 0 10px #FF4444;
        }
        #enemy-label {
            color: rgba(255,255,255,0.6);
            font-size: 0.8rem;
            text-align: center;
        }

        #gameover {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.9);
            z-index: 200;
            gap: 20px;
        }
        #gameover.show { display: flex; }
        #gameover h2 {
            font-size: 3rem;
            color: var(--c1);
            text-shadow: 0 0 30px var(--c1);
        }
        #final-score {
            font-size: 2rem;
            color: white;
        }

        .particle {
            position: fixed;
            pointer-events: none;
            border-radius: 50%;
            z-index: 150;
        }

        #settings-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 50;
            transition: all 0.2s;
        }
        #settings-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: rotate(45deg);
        }

        #keybind-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.9);
            z-index: 300;
        }
        #keybind-modal.show { display: flex; }
        
        #keybind-panel {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid var(--c1);
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 0 40px var(--c1);
        }
        #keybind-panel h2 {
            color: white;
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 10px var(--c1);
        }
        
        .keybind-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }
        .keybind-label {
            color: rgba(255,255,255,0.8);
            font-size: 0.95rem;
        }
        .keybind-key {
            min-width: 80px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .keybind-key:hover {
            border-color: var(--c1);
            box-shadow: 0 0 10px var(--c1);
        }
        .keybind-key.listening {
            border-color: #FFD700;
            box-shadow: 0 0 15px #FFD700;
            animation: pulse 0.5s infinite alternate;
        }
        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        .keybind-presets {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .preset-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--c2), var(--c1));
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .preset-btn:hover {
            transform: scale(1.05);
        }
        
        #keybind-close {
            display: block;
            width: 100%;
            margin-top: 20px;
            padding: 12px;
            background: linear-gradient(135deg, var(--c1), var(--c2));
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #keybind-close:hover {
            transform: scale(1.02);
        }

        .keybind-hint {
            color: rgba(255,255,255,0.5);
            font-size: 0.75rem;
            text-align: center;
            margin-top: 12px;
        }
    </style>
</head>
<body class="w0">
    <div id="title-screen">
        <h1>RHYTHMIA</h1>
        <p>„É™„Ç∫„É†„Å´‰πó„Å£„Å¶„Éñ„É≠„ÉÉ„ÇØ„ÇíÁ©ç„ÇÅÔºÅ</p>
        <button id="title-start-btn">‚ñ∂ START</button>
    </div>

    <div id="game" style="display:none;">
        <div id="world-display">üéÄ „É°„É≠„Éá„Ç£„Ç¢</div>
        
        <div id="score-display">0</div>
        <div id="combo">10 COMBO!</div>
        
        <div id="enemy-label">üëª „Éé„Ç§„Ç∫„É™„É≥„Ç∞</div>
        <div id="enemy-bar"><div id="enemy-fill" style="width:100%"></div></div>
        
        <div id="game-area">
            <div id="board-wrap">
                <div id="board"></div>
                <div id="active-piece"></div>
            </div>
            <div id="next-wrap">
                <div id="next-label">NEXT</div>
                <div id="next"></div>
            </div>
        </div>
        
        <div id="beat-bar">
            <div id="beat-target"></div>
            <div id="beat-fill" style="width:0%"></div>
        </div>
        
        <div id="controls">
            <button class="ctrl-btn" data-action="rotateLeft">‚Ü∂</button>
            <button class="ctrl-btn" data-action="rotateRight">‚Üª</button>
            <button class="ctrl-btn" data-action="left">‚Üê</button>
            <button class="ctrl-btn" data-action="down">‚Üì</button>
            <button class="ctrl-btn" data-action="right">‚Üí</button>
            <button class="ctrl-btn" data-action="drop">‚¨á</button>
        </div>
    </div>

    <div id="judgment"></div>

    <button id="settings-btn">‚öô</button>

    <div id="keybind-modal">
        <div id="keybind-panel">
            <h2>‚å®Ô∏è „Ç≠„Éº„Éê„Ç§„É≥„ÉâË®≠ÂÆö</h2>
            
            <div class="keybind-row">
                <span class="keybind-label">‚¨ÖÔ∏è Â∑¶ÁßªÂãï</span>
                <button class="keybind-key" data-action="left">‚Üê</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">‚û°Ô∏è Âè≥ÁßªÂãï</span>
                <button class="keybind-key" data-action="right">‚Üí</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">‚¨áÔ∏è ‰∏ãÁßªÂãï</span>
                <button class="keybind-key" data-action="down">‚Üì</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">üîÑ ÂõûËª¢ÔºàÂè≥Ôºâ</span>
                <button class="keybind-key" data-action="rotate">‚Üë</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">‚Ü∂ ÂõûËª¢ÔºàÂ∑¶Ôºâ</span>
                <button class="keybind-key" data-action="rotateLeft">Z</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">‚Üª ÂõûËª¢ÔºàÂè≥Ôºâ</span>
                <button class="keybind-key" data-action="rotateRight">X</button>
            </div>
            <div class="keybind-row">
                <span class="keybind-label">‚¨á „Éè„Éº„Éâ„Éâ„É≠„ÉÉ„Éó</span>
                <button class="keybind-key" data-action="drop">Space</button>
            </div>
            
            <div class="keybind-presets">
                <button class="preset-btn" data-preset="arrows">Áü¢Âç∞„Ç≠„Éº</button>
                <button class="preset-btn" data-preset="wasd">WASD</button>
                <button class="preset-btn" data-preset="vim">VimÈ¢® (HJKL)</button>
                <button class="preset-btn" data-preset="gamer">„Ç≤„Éº„Éû„Éº (ESDF)</button>
            </div>
            
            <p class="keybind-hint">„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åã„ÇâÂ•Ω„Åç„Å™„Ç≠„Éº„ÇíÊäº„Åó„Å¶Ë®≠ÂÆö</p>
            
            <button id="keybind-close">‚úî ÂÆå‰∫Ü</button>
        </div>
    </div>

    <div id="gameover">
        <h2>GAME OVER</h2>
        <div id="final-score">0</div>
        <button id="retry-btn" style="padding:15px 40px;font-size:1.2rem;background:linear-gradient(135deg,var(--c1),var(--c2));border:none;border-radius:30px;color:white;cursor:pointer;">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>

    <script>
        const W = 10, H = 18;
        const WORLDS = [
            { name: 'üéÄ „É°„É≠„Éá„Ç£„Ç¢', bpm: 100, colors: ['#FF6B9D','#FF8FAB','#FFB6C1','#C44569','#E8668B','#D4587D','#B84A6F'] },
            { name: 'üåä „Éè„Éº„É¢„Éã„Ç¢', bpm: 110, colors: ['#4ECDC4','#45B7AA','#3DA69B','#35958C','#2D847D','#26736E','#1A535C'] },
            { name: '‚òÄÔ∏è „ÇØ„É¨„Ç∑„Çß„É≥„ÉÄ', bpm: 120, colors: ['#FFE66D','#FFD93D','#F7B731','#ECA700','#D19600','#B68600','#9B7600'] },
            { name: 'üî• „Éï„Ç©„É´„ÉÜ„Ç£„ÉÉ„Ç∑„É¢', bpm: 140, colors: ['#FF6B6B','#FF5252','#FF3838','#FF1F1F','#E61717','#CC0F0F','#B30707'] },
            { name: '‚ú® ÈùôÂØÇ„ÅÆÈñì', bpm: 160, colors: ['#A29BFE','#9B8EFD','#9381FC','#8B74FB','#8367FA','#7B5AF9','#6C5CE7'] }
        ];
        
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];

        let board, piece, piecePos, nextPiece, score, combo, level, lines;
        let worldIdx, enemyHP, gameOver, paused;
        let beatPhase, lastBeat, audioCtx;
        let dropTimer, beatTimer;
        let beatRafId = null;
        let lockTimeoutId = null;
        let cellSize = 20;
        let gapSize = 1;
        let lastRotationWasKick = false;
        let lastMoveWasRotation = false;

        // Piece type identifiers (I, O, T, S, Z, J, L)
        const PIECE_TYPES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];

        // SRS Wall Kick Data for JLSTZ pieces
        const WALL_KICKS = {
            '0>1': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '1>0': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '1>2': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '2>1': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '2>3': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '3>2': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '3>0': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '0>3': [[0,0], [1,0], [1,-1], [0,2], [1,2]]
        };

        // SRS Wall Kick Data for I piece (different offsets)
        const I_WALL_KICKS = {
            '0>1': [[0,0], [-2,0], [1,0], [-2,1], [1,-2]],
            '1>0': [[0,0], [2,0], [-1,0], [2,-1], [-1,2]],
            '1>2': [[0,0], [-1,0], [2,0], [-1,-2], [2,1]],
            '2>1': [[0,0], [1,0], [-2,0], [1,2], [-2,-1]],
            '2>3': [[0,0], [2,0], [-1,0], [2,-1], [-1,2]],
            '3>2': [[0,0], [-2,0], [1,0], [-2,1], [1,-2]],
            '3>0': [[0,0], [1,0], [-2,0], [1,2], [-2,-1]],
            '0>3': [[0,0], [-1,0], [2,0], [-1,-2], [2,1]]
        };

        const $ = id => document.getElementById(id);
        const boardEl = $('board');
        const nextEl = $('next');
        const scoreEl = $('score-display');
        const comboEl = $('combo');
        const judgmentEl = $('judgment');
        const beatFill = $('beat-fill');
        const enemyFill = $('enemy-fill');
        const enemyLabel = $('enemy-label');
        const worldDisplay = $('world-display');
        const boardWrap = $('board-wrap');
        const activePieceEl = $('active-piece');

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, dur = 0.1, type = 'sine') {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + dur);
        }

        function playDrum() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function playLineClear(count) {
            const freqs = [523, 659, 784, 1047];
            freqs.slice(0, count).forEach((f, i) => setTimeout(() => playTone(f, 0.15, 'triangle'), i * 60));
        }

        function spawnParticles(x, y, color, count = 8) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                const size = Math.random() * 10 + 5;
                const angle = (Math.PI * 2 / count) * i;
                const dist = Math.random() * 80 + 40;
                p.style.cssText = \`
                    left: \${x}px; top: \${y}px;
                    width: \${size}px; height: \${size}px;
                    background: \${color};
                    box-shadow: 0 0 10px \${color};
                    transition: all 0.5s ease-out;
                \`;
                document.body.appendChild(p);
                requestAnimationFrame(() => {
                    p.style.transform = \`translate(\${Math.cos(angle) * dist}px, \${Math.sin(angle) * dist}px) scale(0)\`;
                    p.style.opacity = '0';
                });
                setTimeout(() => p.remove(), 500);
            }
        }

        function createBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = \`repeat(\${W}, 1fr)\`;
            for (let i = 0; i < W * H; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                boardEl.appendChild(cell);
            }
            
            requestAnimationFrame(() => {
                const firstCell = boardEl.querySelector('.cell');
                if (firstCell) {
                    const rect = firstCell.getBoundingClientRect();
                    cellSize = rect.width;
                }
            });
        }

        function randomPiece() {
            const world = WORLDS[worldIdx];
            const shapeIdx = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[shapeIdx].map(row => [...row]); // Deep copy
            const color = world.colors[Math.floor(Math.random() * world.colors.length)];
            const type = PIECE_TYPES[shapeIdx];
            return { shape, color, type, rotation: 0 };
        }

        function drawBoard() {
            const cells = boardEl.children;
            const display = board.map(r => [...r]);
            
            if (piece) {
                let gy = piecePos.y;
                while (!collision(piece, piecePos.x, gy + 1)) gy++;
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = gy + py, bx = piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W && !display[by][bx]) {
                                display[by][bx] = { color: piece.color, ghost: true };
                            }
                        }
                    });
                });
            }
            
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const cell = cells[y * W + x];
                    const val = display[y][x];
                    if (val) {
                        cell.className = 'cell filled' + (val.ghost ? ' ghost' : '');
                        cell.style.backgroundColor = val.color;
                        cell.style.color = val.color;
                    } else {
                        cell.className = 'cell';
                        cell.style.backgroundColor = '';
                        cell.style.color = '';
                    }
                }
            }
        }

        function drawActivePiece(instant = false) {
            if (!piece) {
                activePieceEl.innerHTML = '';
                return;
            }

            const firstCell = boardEl.querySelector('.cell');
            if (firstCell) {
                const rect = firstCell.getBoundingClientRect();
                cellSize = rect.width;
            }

            const unit = cellSize + gapSize;
            
            if (activePieceEl.children.length === 0 || activePieceEl.dataset.color !== piece.color) {
                activePieceEl.innerHTML = '';
                piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const cell = document.createElement('div');
                            cell.className = 'piece-cell';
                            cell.style.width = cellSize + 'px';
                            cell.style.height = cellSize + 'px';
                            cell.style.backgroundColor = piece.color;
                            cell.style.color = piece.color;
                            cell.style.left = (px * unit) + 'px';
                            cell.style.top = (py * unit) + 'px';
                            activePieceEl.appendChild(cell);
                        }
                    });
                });
                activePieceEl.dataset.color = piece.color;
            }

            if (instant) {
                activePieceEl.classList.add('dropping');
            } else {
                activePieceEl.classList.remove('dropping');
            }
            
            const x = piecePos.x * unit;
            const y = piecePos.y * unit;
            activePieceEl.style.transform = \`translate(\${x}px, \${y}px)\`;
        }

        function rebuildActivePiece() {
            activePieceEl.innerHTML = '';
            activePieceEl.dataset.color = '';
            drawActivePiece(true);
        }

        function drawNext() {
            if (!nextPiece) return;
            const shape = nextPiece.shape;
            nextEl.innerHTML = '';
            nextEl.style.gridTemplateColumns = \`repeat(\${shape[0].length}, 1fr)\`;
            shape.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'next-cell';
                    if (val) {
                        cell.style.backgroundColor = nextPiece.color;
                        cell.style.boxShadow = \`0 0 8px \${nextPiece.color}\`;
                    }
                    nextEl.appendChild(cell);
                });
            });
        }

        function collision(p, x, y) {
            return p.shape.some((row, py) =>
                row.some((val, px) => {
                    if (!val) return false;
                    const nx = x + px, ny = y + py;
                    return nx < 0 || nx >= W || ny >= H || (ny >= 0 && board[ny][nx]);
                })
            );
        }

        // Rotate shape clockwise (right)
        function rotateShapeCW(shape) {
            return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
        }

        // Rotate shape counter-clockwise (left)
        function rotateShapeCCW(shape) {
            return shape[0].map((_, i) => shape.map(row => row[row.length - 1 - i]));
        }

        function rotate(p, direction = 1) {
            const newRotation = (p.rotation + direction + 4) % 4;
            return {
                ...p,
                shape: direction === 1 ? rotateShapeCW(p.shape) : rotateShapeCCW(p.shape),
                rotation: newRotation
            };
        }

        // Get wall kick data for a piece and rotation
        function getWallKicks(pieceType, fromRot, toRot) {
            const key = fromRot + '>' + toRot;
            if (pieceType === 'I') return I_WALL_KICKS[key] || [[0,0]];
            if (pieceType === 'O') return [[0,0]]; // O piece doesn't need kicks
            return WALL_KICKS[key] || [[0,0]];
        }

        // Try to rotate with wall kicks
        function tryRotate(direction) {
            if (!piece) return false;
            
            const fromRot = piece.rotation;
            const rotated = rotate(piece, direction);
            const toRot = rotated.rotation;
            const kicks = getWallKicks(piece.type, fromRot, toRot);
            
            for (let i = 0; i < kicks.length; i++) {
                const [dx, dy] = kicks[i];
                if (!collision(rotated, piecePos.x + dx, piecePos.y - dy)) {
                    piece = rotated;
                    piecePos.x += dx;
                    piecePos.y -= dy;
                    lastRotationWasKick = (i > 0);
                    lastMoveWasRotation = true;
                    return true;
                }
            }
            return false;
        }

        // T-Spin detection
        function checkTSpin() {
            if (!piece || piece.type !== 'T' || !lastMoveWasRotation) return 'none';
            
            // Check 4 corners of T piece center
            const cx = piecePos.x + 1;
            const cy = piecePos.y + 1;
            const corners = [
                [cx - 1, cy - 1], [cx + 1, cy - 1],
                [cx - 1, cy + 1], [cx + 1, cy + 1]
            ];
            
            let filledCorners = 0;
            let frontCorners = 0;
            
            corners.forEach(([x, y], i) => {
                const blocked = x < 0 || x >= W || y >= H || (y >= 0 && board[y] && board[y][x]);
                if (blocked) {
                    filledCorners++;
                    // Front corners based on rotation
                    const frontIdx = [[0,1], [1,3], [2,3], [0,2]][piece.rotation];
                    if (frontIdx.includes(i)) frontCorners++;
                }
            });
            
            if (filledCorners >= 3) {
                if (frontCorners >= 2 || lastRotationWasKick) return 'tspin';
                return 'mini';
            }
            return 'none';
        }

        function spawnNextPiece() {
            piece = nextPiece;
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            rebuildActivePiece();
            drawNext();
            drawBoard();
            if (collision(piece, piecePos.x, piecePos.y)) {
                endGame();
            }
        }

        function lock() {
            if (!piece) return; // Guard against multiple lock calls
            
            const onBeat = beatPhase > 0.75 || beatPhase < 0.15;
            let mult = 1;
            
            // Check T-Spin before clearing piece
            const tSpinType = checkTSpin();
            
            if (onBeat) {
                mult = 2;
                combo++;
                showJudgment('PERFECT!', '#FFD700');
                playTone(1047, 0.2, 'triangle');
                const rect = boardWrap.getBoundingClientRect();
                spawnParticles(rect.left + rect.width/2, rect.top + rect.height/2, '#FFD700', 12);
            } else {
                combo = 0;
            }
            
            updateCombo();
            
            // Store piece reference before clearing
            const lockedPiece = piece;
            const lockedPos = { ...piecePos };
            
            // Clear piece immediately to prevent race conditions with dropTimer
            piece = null;
            activePieceEl.innerHTML = '';
            lastMoveWasRotation = false;
            
            lockedPiece.shape.forEach((row, py) => {
                row.forEach((val, px) => {
                    if (val) {
                        const by = lockedPos.y + py, bx = lockedPos.x + px;
                        if (by >= 0 && by < H) {
                            board[by][bx] = { color: lockedPiece.color };
                        }
                    }
                });
            });
            
            let cleared = 0;
            const newBoard = [];
            const clearingRows = [];
            
            board.forEach((row, y) => {
                if (row.every(c => c !== null)) {
                    cleared++;
                    clearingRows.push(y);
                } else {
                    newBoard.push(row);
                }
            });
            
            if (cleared > 0) {
                const cells = boardEl.children;
                clearingRows.forEach(y => {
                    for (let x = 0; x < W; x++) {
                        cells[y * W + x].classList.add('clearing');
                    }
                });
                
                setTimeout(() => {
                    while (newBoard.length < H) newBoard.unshift(Array(W).fill(null));
                    board = newBoard;
                    
                    // Base line clear points
                    let pts = [0, 100, 300, 500, 800][cleared] * (level + 1) * mult * Math.max(1, combo);
                    
                    // T-Spin bonuses
                    if (tSpinType === 'tspin') {
                        const tSpinClearedIndex = Math.min(cleared, 3);
                        const tSpinPts = [400, 800, 1200, 1600][tSpinClearedIndex] * (level + 1);
                        pts += tSpinPts;
                        const tSpinNames = ['', 'SINGLE', 'DOUBLE', 'TRIPLE'];
                        showJudgment(cleared > 0 ? 'T-SPIN ' + tSpinNames[tSpinClearedIndex] + '!' : 'T-SPIN!', '#FF00FF');
                        playTone(880, 0.15, 'triangle');
                    } else if (tSpinType === 'mini') {
                        // Mini T-Spins only distinguish between 0-line and 1+-line clears;
                        // any Mini T-Spin that clears 2 or more lines uses the 1-line bonus.
                        const miniClearIndex = cleared <= 0 ? 0 : 1;
                        const miniPts = [100, 200][miniClearIndex] * (level + 1);
                        pts += miniPts;
                        showJudgment('MINI T-SPIN!', '#FF88FF');
                    }
                    
                    score += pts;
                    lines += cleared;
                    
                    let tSpinDamageMult;
                    if (tSpinType === 'tspin') {
                        tSpinDamageMult = 1.5;
                    } else if (tSpinType === 'mini') {
                        // Mini T-Spins intentionally do not get extra damage (1x)
                        tSpinDamageMult = 1;
                    } else {
                        tSpinDamageMult = 1;
                    }
                    enemyHP = Math.max(0, enemyHP - cleared * 8 * mult * tSpinDamageMult);
                    enemyFill.style.width = enemyHP + '%';
                    
                    if (enemyHP <= 0) {
                        nextWorld();
                    }
                    
                    level = Math.floor(lines / 10);
                    updateScore();
                    playLineClear(cleared);
                    boardWrap.classList.add('shake');
                    setTimeout(() => boardWrap.classList.remove('shake'), 200);
                    
                    drawBoard();
                    spawnNextPiece();
                }, 300);
                return;
            }
            
            // T-Spin with no lines still gives points
            if (tSpinType === 'tspin') {
                score += 400 * (level + 1);
                showJudgment('T-SPIN!', '#FF00FF');
                playTone(880, 0.15, 'triangle');
                updateScore();
            } else if (tSpinType === 'mini') {
                score += 100 * (level + 1);
                showJudgment('MINI T-SPIN!', '#FF88FF');
                updateScore();
            }
            
            spawnNextPiece();
        }

        function move(dx, dy) {
            if (gameOver || paused || !piece) return;
            if (!collision(piece, piecePos.x + dx, piecePos.y + dy)) {
                piecePos.x += dx;
                piecePos.y += dy;
                if (dx !== 0) playTone(392, 0.05, 'square');
                drawActivePiece();
                drawBoard();
            } else if (dy > 0) {
                lock();
            }
        }

        function rotatePiece(direction = 1) {
            if (gameOver || paused || !piece) return;
            if (tryRotate(direction)) {
                playTone(direction === 1 ? 523 : 440, 0.08);
                rebuildActivePiece();
                drawBoard();
            }
        }

        function rotatePieceLeft() {
            rotatePiece(-1);
        }

        function rotatePieceRight() {
            rotatePiece(1);
        }

        function hardDrop() {
            if (gameOver || paused || !piece) return;
            
            // Cancel any pending lock timeout to prevent double-locking
            if (lockTimeoutId !== null) {
                clearTimeout(lockTimeoutId);
                lockTimeoutId = null;
            }
            
            activePieceEl.classList.add('dropping');
            while (!collision(piece, piecePos.x, piecePos.y + 1)) {
                piecePos.y++;
            }
            playTone(196, 0.1, 'sawtooth');
            drawActivePiece(true);
            drawBoard();
            lockTimeoutId = setTimeout(() => {
                lockTimeoutId = null;
                lock();
            }, 30);
        }

        function showJudgment(text, color) {
            judgmentEl.textContent = text;
            judgmentEl.style.color = color;
            judgmentEl.style.textShadow = \`0 0 30px \${color}\`;
            judgmentEl.className = '';
            void judgmentEl.offsetWidth;
            judgmentEl.classList.add('show');
        }

        function updateScore() {
            scoreEl.textContent = score.toLocaleString();
            scoreEl.classList.add('pop');
            setTimeout(() => scoreEl.classList.remove('pop'), 100);
        }

        function updateCombo() {
            if (combo >= 2) {
                comboEl.textContent = combo + ' COMBO!';
                comboEl.classList.add('show');
                if (combo >= 5) comboEl.classList.add('big');
                else comboEl.classList.remove('big');
            } else {
                comboEl.classList.remove('show', 'big');
            }
        }

        function nextWorld() {
            worldIdx++;
            if (worldIdx >= WORLDS.length) {
                showJudgment('üéâ CLEAR!', '#FFD700');
                setTimeout(() => {
                    worldIdx = 0;
                    enemyHP = 100;
                    setWorld();
                }, 2000);
            } else {
                showJudgment('WORLD CLEAR!', '#00FF00');
                enemyHP = 100;
                setWorld();
            }
        }

        function setWorld() {
            const world = WORLDS[worldIdx];
            document.body.className = 'w' + worldIdx;
            worldDisplay.textContent = world.name;
            enemyFill.style.width = enemyHP + '%';
            
            clearInterval(beatTimer);
            const interval = 60000 / world.bpm;
            lastBeat = Date.now();
            beatTimer = setInterval(() => {
                lastBeat = Date.now();
                boardWrap.classList.add('beat');
                playDrum();
                setTimeout(() => boardWrap.classList.remove('beat'), 100);
            }, interval);
        }

        function startGame() {
            // Cancel previous RAF loop if exists
            if (beatRafId !== null) {
                cancelAnimationFrame(beatRafId);
            }
            
            // Cancel any pending lock timeout
            if (lockTimeoutId !== null) {
                clearTimeout(lockTimeoutId);
                lockTimeoutId = null;
            }
            
            // Reset beat state
            beatPhase = 0;
            lastBeat = Date.now();
            beatFill.style.width = '0%';
            
            board = Array(H).fill().map(() => Array(W).fill(null));
            score = 0;
            combo = 0;
            level = 0;
            lines = 0;
            worldIdx = 0;
            enemyHP = 100;
            gameOver = false;
            paused = false;
            
            piece = randomPiece();
            nextPiece = randomPiece();
            piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            
            createBoard();
            
            requestAnimationFrame(() => {
                const firstCell = boardEl.querySelector('.cell');
                if (firstCell) {
                    const rect = firstCell.getBoundingClientRect();
                    cellSize = rect.width;
                }
                
                drawBoard();
                rebuildActivePiece();
                drawNext();
                updateScore();
                updateCombo();
                setWorld();
            });
            
            $('title-screen').style.display = 'none';
            $('game').style.display = 'flex';
            $('gameover').classList.remove('show');
            
            clearInterval(dropTimer);
            dropTimer = setInterval(() => {
                if (!gameOver && !paused) {
                    move(0, 1);
                }
            }, 500);
            
            beatRafId = requestAnimationFrame(function updateBeat() {
                if (!gameOver) {
                    const world = WORLDS[worldIdx];
                    const interval = 60000 / world.bpm;
                    const elapsed = Date.now() - lastBeat;
                    beatPhase = (elapsed % interval) / interval;
                    beatFill.style.width = (beatPhase * 100) + '%';
                    beatRafId = requestAnimationFrame(updateBeat);
                }
            });
        }

        function endGame() {
            gameOver = true;
            clearInterval(dropTimer);
            clearInterval(beatTimer);
            if (beatRafId !== null) {
                cancelAnimationFrame(beatRafId);
                beatRafId = null;
            }
            if (lockTimeoutId !== null) {
                clearTimeout(lockTimeoutId);
                lockTimeoutId = null;
            }
            $('final-score').textContent = score.toLocaleString() + ' pts';
            $('gameover').classList.add('show');
            playTone(131, 0.5, 'sawtooth');
        }

        $('title-start-btn').onclick = () => {
            initAudio();
            startGame();
        };
        
        $('retry-btn').onclick = () => {
            startGame();
        };

        document.querySelectorAll('.ctrl-btn').forEach(btn => {
            const action = btn.dataset.action;
            let lastTrigger = 0;
            const handler = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const now = Date.now();
                if (now - lastTrigger < 100) return;
                lastTrigger = now;
                
                switch(action) {
                    case 'left': move(-1, 0); break;
                    case 'right': move(1, 0); break;
                    case 'down': move(0, 1); break;
                    case 'rotate': rotatePieceRight(); break;
                    case 'rotateLeft': rotatePieceLeft(); break;
                    case 'rotateRight': rotatePieceRight(); break;
                    case 'drop': hardDrop(); break;
                }
            };
            
            btn.addEventListener('touchend', handler, { passive: false });
            btn.addEventListener('click', (e) => {
                if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
                handler(e);
            });
        });

        const DEFAULT_KEYBINDS = {
            left: 'ArrowLeft',
            right: 'ArrowRight',
            down: 'ArrowDown',
            rotate: 'ArrowUp',
            rotateLeft: 'z',
            rotateRight: 'x',
            drop: ' '
        };
        
        const PRESETS = {
            arrows: { left: 'ArrowLeft', right: 'ArrowRight', down: 'ArrowDown', rotate: 'ArrowUp', rotateLeft: 'z', rotateRight: 'x', drop: ' ' },
            wasd: { left: 'a', right: 'd', down: 's', rotate: 'w', rotateLeft: 'q', rotateRight: 'e', drop: ' ' },
            vim: { left: 'h', right: 'l', down: 'j', rotate: 'k', rotateLeft: 'u', rotateRight: 'i', drop: ' ' },
            gamer: { left: 's', right: 'f', down: 'd', rotate: 'e', rotateLeft: 'q', rotateRight: 'r', drop: ' ' }
        };
        
        let keybinds = { ...DEFAULT_KEYBINDS };
        let listeningFor = null;
        
        function loadKeybinds() {
            try {
                const saved = localStorage.getItem('rhythmia-keybinds');
                if (saved) {
                    keybinds = { ...DEFAULT_KEYBINDS, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.log('„Ç≠„Éº„Éê„Ç§„É≥„ÉâË™≠„ÅøËæº„ÅøÂ§±Êïó');
            }
            updateKeybindDisplay();
        }
        
        function saveKeybinds() {
            try {
                localStorage.setItem('rhythmia-keybinds', JSON.stringify(keybinds));
            } catch (e) {
                console.log('„Ç≠„Éº„Éê„Ç§„É≥„Éâ‰øùÂ≠òÂ§±Êïó');
            }
        }
        
        function formatKeyName(key) {
            const keyNames = {
                ' ': 'Space',
                'ArrowLeft': '‚Üê',
                'ArrowRight': '‚Üí',
                'ArrowUp': '‚Üë',
                'ArrowDown': '‚Üì',
                'Enter': 'Enter',
                'Shift': 'Shift',
                'Control': 'Ctrl',
                'Alt': 'Alt',
                'Tab': 'Tab',
                'Escape': 'Esc',
                'Backspace': '‚å´'
            };
            return keyNames[key] || key.toUpperCase();
        }
        
        function updateKeybindDisplay() {
            document.querySelectorAll('.keybind-key').forEach(btn => {
                const action = btn.dataset.action;
                if (keybinds[action]) {
                    btn.textContent = formatKeyName(keybinds[action]);
                }
            });
        }
        
        const keybindModal = $('keybind-modal');
        const settingsBtn = $('settings-btn');
        
        settingsBtn.onclick = () => {
            keybindModal.classList.add('show');
            paused = true;
        };
        
        $('keybind-close').onclick = () => {
            keybindModal.classList.remove('show');
            listeningFor = null;
            document.querySelectorAll('.keybind-key').forEach(k => k.classList.remove('listening'));
            paused = false;
            saveKeybinds();
        };
        
        document.querySelectorAll('.keybind-key').forEach(btn => {
            btn.onclick = () => {
                document.querySelectorAll('.keybind-key').forEach(k => k.classList.remove('listening'));
                btn.classList.add('listening');
                btn.textContent = '...';
                listeningFor = btn.dataset.action;
            };
        });
        
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.onclick = () => {
                const preset = PRESETS[btn.dataset.preset];
                if (preset) {
                    keybinds = { ...preset };
                    updateKeybindDisplay();
                    playTone(880, 0.1);
                }
            };
        });
        
        document.addEventListener('keydown', e => {
            if (listeningFor && keybindModal.classList.contains('show')) {
                e.preventDefault();
                
                if (e.key === 'Escape') {
                    document.querySelectorAll('.keybind-key').forEach(k => k.classList.remove('listening'));
                    listeningFor = null;
                    updateKeybindDisplay();
                    return;
                }
                
                keybinds[listeningFor] = e.key;
                updateKeybindDisplay();
                document.querySelectorAll('.keybind-key').forEach(k => k.classList.remove('listening'));
                listeningFor = null;
                playTone(523, 0.1);
                return;
            }
            
            if (keybindModal.classList.contains('show')) return;
            
            if (e.key === keybinds.left) { move(-1, 0); lastMoveWasRotation = false; }
            else if (e.key === keybinds.right) { move(1, 0); lastMoveWasRotation = false; }
            else if (e.key === keybinds.down) { move(0, 1); lastMoveWasRotation = false; }
            else if (e.key === keybinds.rotate) rotatePieceRight();
            else if (e.key === keybinds.rotateLeft || e.key === keybinds.rotateLeft.toUpperCase()) rotatePieceLeft();
            else if (e.key === keybinds.rotateRight || e.key === keybinds.rotateRight.toUpperCase()) rotatePieceRight();
            else if (e.key === keybinds.drop) { e.preventDefault(); hardDrop(); lastMoveWasRotation = false; }
        });

        beatPhase = 0;
        lastBeat = Date.now();
        loadKeybinds();
    <\/script>
</body>
</html>`;

        // Multiplayer Battle Arena HTML
        gameContent.multiplayer = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>BATTLE ARENA</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }
        
        html, body { 
            height: 100%; 
            overflow: hidden; 
            font-family: 'Orbitron', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
        }

        :root {
            --p1-color: #4ECDC4;
            --p1-glow: rgba(78, 205, 196, 0.5);
            --p2-color: #FF6B9D;
            --p2-glow: rgba(255, 107, 157, 0.5);
            --gold: #FFD700;
            --danger: #FF4444;
        }

        .lobby {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            padding: 20px;
        }

        .lobby h1 {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            letter-spacing: 0.2em;
            background: linear-gradient(135deg, var(--gold), #FF6B35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px var(--gold);
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { filter: drop-shadow(0 0 20px var(--gold)); }
            50% { filter: drop-shadow(0 0 40px #FF6B35); }
        }

        .lobby-subtitle {
            color: rgba(255,255,255,0.6);
            font-size: 1rem;
            letter-spacing: 0.3em;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 700px;
        }

        .mode-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 30px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .mode-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: var(--gold);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4), 0 0 30px rgba(255,215,0,0.2);
        }

        .mode-card.online {
            border-color: var(--p1-color);
        }
        .mode-card.online:hover {
            border-color: var(--p1-color);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4), 0 0 30px var(--p1-glow);
        }

        .mode-icon {
            font-size: 3rem;
            margin-bottom: 15px;
        }

        .mode-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 8px;
        }

        .mode-card.online .mode-title {
            color: var(--p1-color);
        }

        .mode-desc {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
            font-family: sans-serif;
        }

        /* Online Lobby Screen */
        .online-lobby {
            display: none;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 25px;
            padding: 20px;
            position: relative;
        }
        .online-lobby.active { display: flex; }

        .online-title {
            font-size: 2rem;
            font-weight: 900;
            color: var(--p1-color);
            text-shadow: 0 0 30px var(--p1-glow);
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            color: rgba(255,255,255,0.7);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
            transition: background 0.3s;
        }
        .status-dot.connected { background: #4ade80; box-shadow: 0 0 10px #4ade80; }
        .status-dot.connecting { background: #fbbf24; animation: blink 1s infinite; }
        .status-dot.error { background: #ef4444; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Name Entry Screen */
        .name-entry-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .name-entry-screen.hidden { display: none; }

        .name-entry-title {
            font-size: 1.2rem;
            color: rgba(255,255,255,0.8);
            font-family: sans-serif;
        }

        .name-entry-input {
            padding: 15px 30px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            text-align: center;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 12px;
            color: white;
            width: 280px;
        }

        .name-entry-input:focus {
            outline: none;
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }

        .name-entry-btn {
            padding: 15px 50px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), #FF6B35);
            border: none;
            border-radius: 30px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
        }

        .name-entry-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--gold);
        }

        .name-entry-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Room Browser Screen */
        .room-browser-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            width: 100%;
            max-width: 500px;
        }

        .room-browser-screen.active { display: flex; }

        .player-name-badge {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .player-name-badge span {
            color: var(--gold);
            font-weight: 700;
        }

        /* Tab Widget */
        .tab-widget {
            width: 100%;
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .tab-header {
            display: flex;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .tab-btn {
            flex: 1;
            padding: 15px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.5);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .tab-btn:hover {
            color: rgba(255,255,255,0.8);
            background: rgba(255,255,255,0.05);
        }

        .tab-btn.active {
            color: var(--p1-color);
            background: rgba(78,205,196,0.1);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--p1-color);
        }

        .tab-content {
            padding: 20px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        /* Create Room Tab */
        .create-room-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .form-label {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.6);
            font-family: sans-serif;
        }

        .form-input {
            padding: 12px 16px;
            font-family: sans-serif;
            font-size: 1rem;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--p1-color);
        }

        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .toggle-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.8);
            font-family: sans-serif;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.2);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--p1-color);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        .create-room-btn {
            padding: 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--p1-color), #2dd4bf);
            border: none;
            border-radius: 12px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
        }

        .create-room-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px var(--p1-glow);
        }

        /* Room List Tab */
        .room-list-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .room-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 250px;
            overflow-y: auto;
            padding-right: 5px;
        }

        .room-list::-webkit-scrollbar {
            width: 6px;
        }

        .room-list::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .room-list::-webkit-scrollbar-thumb {
            background: var(--p1-color);
            border-radius: 3px;
        }

        .room-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .room-item:hover {
            background: rgba(255,255,255,0.1);
            border-color: var(--p1-color);
        }

        .room-item-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .room-item-name {
            font-weight: 700;
            color: white;
        }

        .room-item-host {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
            font-family: sans-serif;
        }

        .room-item-players {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: var(--p1-color);
        }

        .room-list-empty {
            text-align: center;
            padding: 30px;
            color: rgba(255,255,255,0.4);
            font-family: sans-serif;
        }

        .room-list-divider {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }

        .room-list-divider::before,
        .room-list-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.2);
        }

        .room-list-divider span {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.4);
            font-family: sans-serif;
        }

        .code-join-group {
            display: flex;
            gap: 10px;
        }

        .code-input {
            flex: 1;
            padding: 12px 16px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            text-align: center;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
        }

        .code-input:focus {
            outline: none;
            border-color: var(--p1-color);
        }

        .code-join-btn {
            padding: 12px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--p2-color), #f472b6);
            border: none;
            border-radius: 8px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
        }

        .code-join-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px var(--p2-glow);
        }

        .refresh-btn {
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            align-self: flex-end;
        }

        .refresh-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .online-options {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .online-btn {
            padding: 20px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            border: 2px solid var(--p1-color);
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(78,205,196,0.2), rgba(78,205,196,0.05));
            color: var(--p1-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .online-btn:hover {
            background: linear-gradient(135deg, rgba(78,205,196,0.4), rgba(78,205,196,0.1));
            transform: translateY(-4px);
            box-shadow: 0 10px 30px var(--p1-glow);
        }

        .online-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .room-input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .room-input {
            padding: 15px 25px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            text-align: center;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            color: white;
            width: 200px;
        }

        .room-input:focus {
            outline: none;
            border-color: var(--p1-color);
            box-shadow: 0 0 20px var(--p1-glow);
        }

        .room-input::placeholder {
            color: rgba(255,255,255,0.3);
            letter-spacing: 0.1em;
        }

        .name-input {
            padding: 12px 20px;
            font-family: sans-serif;
            font-size: 1rem;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            width: 200px;
        }

        .name-input:focus {
            outline: none;
            border-color: var(--gold);
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Waiting Room */
        .waiting-room {
            display: none;
            height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
            padding: 20px;
        }
        .waiting-room.active { display: flex; }

        .room-code-display {
            text-align: center;
        }

        .room-code-label {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            margin-bottom: 10px;
        }

        .room-code {
            font-size: 3rem;
            font-weight: 900;
            letter-spacing: 0.5em;
            color: var(--gold);
            text-shadow: 0 0 30px var(--gold);
        }

        .players-list {
            display: flex;
            gap: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-slot {
            padding: 20px 30px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            text-align: center;
            min-width: 150px;
        }

        .player-slot.ready {
            border-color: #4ade80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }

        .player-slot.p1 { border-color: var(--p1-color); }
        .player-slot.p2 { border-color: var(--p2-color); }

        .player-slot-name {
            font-size: 1.2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .player-slot-status {
            font-size: 0.8rem;
            color: rgba(255,255,255,0.5);
        }

        .player-slot.ready .player-slot-status {
            color: #4ade80;
        }

        .waiting-actions {
            display: flex;
            gap: 15px;
        }

        .ready-btn {
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .ready-btn.not-ready {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
        }

        .ready-btn.is-ready {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #000;
        }

        .start-btn {
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--gold), #FF6B35);
            border: none;
            border-radius: 30px;
            color: #000;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .start-btn:not(:disabled):hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px var(--gold);
        }

        .battle-container {
            display: none;
            height: 100%;
            flex-direction: column;
        }

        .battle-container.active {
            display: flex;
        }

        .battle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .vs-display {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .player-tag {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 8px;
        }

        .player-tag.p1 {
            background: linear-gradient(135deg, var(--p1-color), rgba(78,205,196,0.3));
            box-shadow: 0 0 20px var(--p1-glow);
        }

        .player-tag.p2 {
            background: linear-gradient(135deg, var(--p2-color), rgba(255,107,157,0.3));
            box-shadow: 0 0 20px var(--p2-glow);
        }

        .player-name {
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .player-score {
            font-size: 1.5rem;
            font-weight: 900;
        }

        .vs-icon {
            font-size: 2rem;
            color: var(--gold);
            text-shadow: 0 0 20px var(--gold);
            animation: vsPulse 1s ease-in-out infinite;
        }

        @keyframes vsPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .battle-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            padding: 20px;
            position: relative;
        }

        .player-side {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .board-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
        }

        .board-container.p1 {
            border: 3px solid var(--p1-color);
            box-shadow: 0 0 30px var(--p1-glow), inset 0 0 30px rgba(0,0,0,0.5);
        }

        .board-container.p2 {
            border: 3px solid var(--p2-color);
            box-shadow: 0 0 30px var(--p2-glow), inset 0 0 30px rgba(0,0,0,0.5);
        }

        .board-container.attack {
            animation: attackFlash 0.3s ease-out;
        }

        @keyframes attackFlash {
            0% { filter: brightness(1); }
            50% { filter: brightness(2); }
            100% { filter: brightness(1); }
        }

        .board-container.damaged {
            animation: damageShake 0.4s ease-out;
        }

        @keyframes damageShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-10px); }
            40% { transform: translateX(10px); }
            60% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
        }

        .board {
            display: grid;
            gap: 1px;
            background: rgba(0,0,0,0.8);
            padding: 2px;
        }

        .cell {
            width: clamp(14px, 2.5vw, 22px);
            height: clamp(14px, 2.5vw, 22px);
            background: rgba(255,255,255,0.03);
            border-radius: 2px;
            transition: all 0.08s;
        }

        .cell.filled {
            box-shadow: 0 0 8px currentColor, inset 0 0 6px rgba(255,255,255,0.3);
        }

        .cell.ghost {
            opacity: 0.3;
        }

        .cell.garbage {
            background: #666 !important;
            box-shadow: 0 0 5px #444 !important;
        }

        .cell.clearing {
            animation: lineClear 0.3s ease-out forwards;
        }

        @keyframes lineClear {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); background: white; }
            100% { transform: scale(0); opacity: 0; }
        }

        .garbage-meter {
            width: 20px;
            height: 100%;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
        }

        .garbage-fill {
            background: linear-gradient(to top, var(--danger), #FF8888);
            transition: height 0.3s ease-out;
            border-radius: 10px;
        }

        .next-preview {
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px;
        }

        .next-label {
            color: rgba(255,255,255,0.5);
            font-size: 0.65rem;
            text-align: center;
            margin-bottom: 5px;
            letter-spacing: 0.2em;
        }

        .next-grid {
            display: grid;
            gap: 1px;
        }

        .next-cell {
            width: clamp(10px, 2vw, 16px);
            height: clamp(10px, 2vw, 16px);
            border-radius: 2px;
        }

        .center-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
        }

        .attack-notification {
            position: absolute;
            font-size: 2rem;
            font-weight: 900;
            color: var(--danger);
            text-shadow: 0 0 20px var(--danger);
            opacity: 0;
            pointer-events: none;
        }

        .attack-notification.show {
            animation: attackPop 0.8s ease-out forwards;
        }

        @keyframes attackPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
            100% { opacity: 0; transform: translate(-50%, -80%) scale(1); }
        }

        .countdown {
            font-size: 6rem;
            font-weight: 900;
            color: var(--gold);
            text-shadow: 0 0 50px var(--gold);
            animation: countPulse 1s ease-out;
        }

        @keyframes countPulse {
            0% { transform: scale(2); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .controls-hint {
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            font-family: sans-serif;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .control-group span:first-child {
            font-weight: 700;
            color: var(--gold);
        }

        .key-hint {
            display: flex;
            gap: 5px;
        }

        .key {
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .result-overlay {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.95);
            z-index: 200;
            gap: 30px;
        }

        .result-overlay.show {
            display: flex;
        }

        .winner-display {
            font-size: 4rem;
            font-weight: 900;
            animation: winnerPop 0.6s ease-out;
        }

        @keyframes winnerPop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .winner-display.p1 {
            color: var(--p1-color);
            text-shadow: 0 0 50px var(--p1-glow);
        }

        .winner-display.p2 {
            color: var(--p2-color);
            text-shadow: 0 0 50px var(--p2-glow);
        }

        .result-stats {
            display: flex;
            gap: 60px;
            color: white;
        }

        .stat-column {
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.6;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .result-buttons {
            display: flex;
            gap: 20px;
        }

        .result-btn {
            padding: 15px 40px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .result-btn.primary {
            background: linear-gradient(135deg, var(--gold), #FF6B35);
            color: #000;
        }

        .result-btn.secondary {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
        }

        .result-btn:hover {
            transform: scale(1.05);
        }

        .firework {
            position: fixed;
            pointer-events: none;
            z-index: 150;
        }

        .error-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: rgba(239, 68, 68, 0.9);
            border-radius: 8px;
            color: white;
            font-family: sans-serif;
            z-index: 300;
            display: none;
        }
        .error-toast.show { display: block; animation: slideUp 0.3s ease-out; }

        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        @media (max-width: 768px) {
            .battle-area {
                flex-direction: column;
                gap: 20px;
            }
            
            .player-side {
                flex-direction: row;
            }
            
            .garbage-meter {
                width: 100%;
                height: 15px;
                flex-direction: row;
            }
            
            .controls-hint {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="lobby" id="lobby">
        <h1>‚öîÔ∏è BATTLE ARENA</h1>
        <p class="lobby-subtitle">ÂØæÊà¶„É¢„Éº„Éâ„ÇíÈÅ∏Êäû</p>
        
        <div class="mode-grid">
            <div class="mode-card" onclick="startBattle('local')">
                <div class="mode-icon">üë•</div>
                <div class="mode-title">LOCAL 2P</div>
                <div class="mode-desc">Âêå„Åò„Ç≠„Éº„Éú„Éº„Éâ„Åß2‰∫∫ÂØæÊà¶</div>
            </div>
            <div class="mode-card" onclick="startBattle('ai')">
                <div class="mode-icon">ü§ñ</div>
                <div class="mode-title">VS CPU</div>
                <div class="mode-desc">AI„Å®ÂØæÊà¶</div>
            </div>
            <div class="mode-card online" onclick="showOnlineLobby()">
                <div class="mode-icon">üåê</div>
                <div class="mode-title">ONLINE</div>
                <div class="mode-desc">„Ç™„É≥„É©„Ç§„É≥„ÅßÂØæÊà¶</div>
            </div>
        </div>
    </div>

    <!-- Online Lobby -->
    <div class="online-lobby" id="onlineLobby">
        <button class="back-btn" onclick="backToMainLobby()">‚Üê Êàª„Çã</button>
        
        <h2 class="online-title">üåê ONLINE BATTLE</h2>
        
        <div class="connection-status">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Êú™Êé•Á∂ö</span>
        </div>

        <!-- Step 1: Name Entry -->
        <div class="name-entry-screen" id="nameEntryScreen">
            <div class="name-entry-title">„Éó„É¨„Ç§„É§„ÉºÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
            <input type="text" class="name-entry-input" id="playerNameInput" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ" maxlength="12">
            <button class="name-entry-btn" id="nameEntryBtn" onclick="submitPlayerName()">
                Ê¨°„Å∏ ‚Üí
            </button>
        </div>

        <!-- Step 2: Room Browser -->
        <div class="room-browser-screen" id="roomBrowserScreen">
            <div class="player-name-badge">
                üë§ <span id="displayPlayerName">Player</span>
                <button style="background:none;border:none;color:rgba(255,255,255,0.5);cursor:pointer;font-size:0.8rem;" onclick="editPlayerName()">‚úèÔ∏è</button>
            </div>

            <div class="tab-widget">
                <div class="tab-header">
                    <button class="tab-btn active" onclick="switchTab('create')" id="tabCreate">üè† „É´„Éº„É†‰ΩúÊàê</button>
                    <button class="tab-btn" onclick="switchTab('list')" id="tabList">üìã „É´„Éº„É†„É™„Çπ„Éà</button>
                </div>
                
                <div class="tab-content">
                    <!-- Create Room Tab -->
                    <div class="tab-pane active" id="paneCreate">
                        <div class="create-room-form">
                            <div class="form-group">
                                <label class="form-label">ÈÉ®Â±ãÂêç</label>
                                <input type="text" class="form-input" id="roomNameInput" placeholder="„Éê„Éà„É´„É´„Éº„É†" maxlength="20">
                            </div>
                            
                            <div class="toggle-group">
                                <span class="toggle-label">„É´„Éº„É†„É™„Çπ„Éà„Å´ÂÖ¨Èñã„Åô„Çã</span>
                                <div class="toggle-switch active" id="publicToggle" onclick="togglePublic()"></div>
                            </div>
                            
                            <button class="create-room-btn" onclick="createRoom()">
                                ‚ú® „É´„Éº„É†„Çí‰ΩúÊàê
                            </button>
                        </div>
                    </div>

                    <!-- Room List Tab -->
                    <div class="tab-pane" id="paneList">
                        <div class="room-list-container">
                            <button class="refresh-btn" onclick="refreshRoomList()">üîÑ Êõ¥Êñ∞</button>
                            
                            <div class="room-list" id="roomList">
                                <div class="room-list-empty">
                                    „É´„Éº„É†„ÇíÊ§úÁ¥¢‰∏≠...
                                </div>
                            </div>

                            <div class="room-list-divider">
                                <span>„Åæ„Åü„ÅØ</span>
                            </div>

                            <div class="code-join-group">
                                <input type="text" class="code-input" id="roomCodeInput" placeholder="CODE" maxlength="4">
                                <button class="code-join-btn" onclick="joinRoomByCode()">ÂèÇÂä†</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Waiting Room -->
    <div class="waiting-room" id="waitingRoom">
        <button class="back-btn" onclick="leaveRoom()">‚Üê ÈÄÄÂá∫</button>

        <div class="room-code-display">
            <div class="room-code-label">„É´„Éº„É†„Ç≥„Éº„Éâ</div>
            <div class="room-code" id="displayRoomCode">----</div>
        </div>

        <div class="players-list" id="playersList">
            <div class="player-slot p1" id="slot1">
                <div class="player-slot-name">ÂæÖÊ©ü‰∏≠...</div>
                <div class="player-slot-status">---</div>
            </div>
            <div class="player-slot p2" id="slot2">
                <div class="player-slot-name">ÂæÖÊ©ü‰∏≠...</div>
                <div class="player-slot-status">---</div>
            </div>
        </div>

        <div class="waiting-actions">
            <button class="ready-btn not-ready" id="readyBtn" onclick="toggleReady()">
                ‚úì Ê∫ñÂÇôÂÆå‰∫Ü
            </button>
            <button class="start-btn" id="startGameBtn" onclick="startOnlineGame()" disabled>
                ‚ñ∂ „Ç≤„Éº„É†ÈñãÂßã
            </button>
        </div>
    </div>

    <div class="battle-container" id="battleContainer">
        <div class="battle-header">
            <div class="vs-display">
                <div class="player-tag p1">
                    <span class="player-name" id="p1NameDisplay">PLAYER 1</span>
                    <span class="player-score" id="p1Score">0</span>
                </div>
                <div class="vs-icon">‚öîÔ∏è</div>
                <div class="player-tag p2">
                    <span class="player-name" id="p2NameDisplay">PLAYER 2</span>
                    <span class="player-score" id="p2Score">0</span>
                </div>
            </div>
        </div>

        <div class="battle-area">
            <div class="player-side">
                <div class="next-preview">
                    <div class="next-label">NEXT</div>
                    <div class="next-grid" id="p1Next"></div>
                </div>
                <div class="board-container p1" id="p1BoardWrap">
                    <div class="board" id="p1Board"></div>
                </div>
                <div class="garbage-meter">
                    <div class="garbage-fill" id="p1Garbage" style="height:0%"></div>
                </div>
            </div>

            <div class="center-display">
                <div class="countdown" id="countdown"></div>
                <div class="attack-notification" id="attackNotif"></div>
            </div>

            <div class="player-side">
                <div class="garbage-meter">
                    <div class="garbage-fill" id="p2Garbage" style="height:0%"></div>
                </div>
                <div class="board-container p2" id="p2BoardWrap">
                    <div class="board" id="p2Board"></div>
                </div>
                <div class="next-preview">
                    <div class="next-label">NEXT</div>
                    <div class="next-grid" id="p2Next"></div>
                </div>
            </div>
        </div>

        <div class="controls-hint" id="controlsHint">
            <div class="control-group">
                <span>P1 (WASD)</span>
                <div class="key-hint">
                    <span class="key">A</span><span class="key">S</span><span class="key">D</span><span class="key">W</span><span class="key">Space</span>
                </div>
            </div>
            <div class="control-group">
                <span>P2 (Arrows)</span>
                <div class="key-hint">
                    <span class="key">‚Üê</span><span class="key">‚Üì</span><span class="key">‚Üí</span><span class="key">‚Üë</span><span class="key">Enter</span>
                </div>
            </div>
        </div>
    </div>

    <div class="result-overlay" id="resultOverlay">
        <div class="winner-display" id="winnerText">PLAYER 1 WINS!</div>
        <div class="result-stats">
            <div class="stat-column">
                <div class="stat-label">P1 SCORE</div>
                <div class="stat-value" id="finalP1">0</div>
            </div>
            <div class="stat-column">
                <div class="stat-label">P2 SCORE</div>
                <div class="stat-value" id="finalP2">0</div>
            </div>
        </div>
        <div class="result-buttons">
            <button class="result-btn primary" onclick="handleRematch()">üîÑ REMATCH</button>
            <button class="result-btn secondary" onclick="backToLobby()">‚Üê LOBBY</button>
        </div>
    </div>

    <div class="error-toast" id="errorToast"></div>

    <script>
        const W = 10, H = 20;
        const COLORS = ['#FF6B9D','#4ECDC4','#FFE66D','#A29BFE','#FF6B6B','#6C5CE7','#00D9FF'];
        const SHAPES = [
            [[1,1,1,1]],
            [[1,1],[1,1]],
            [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]],
            [[1,1,0],[0,1,1]],
            [[1,0,0],[1,1,1]],
            [[0,0,1],[1,1,1]]
        ];

        // Game state
        let audioCtx;
        let lastMode = 'local';
        let gameRunning = false;
        let isAI = false;
        let isOnline = false;
        let aiTimer;

        // Online state
        let ws = null;
        let myPlayerId = null;
        let roomCode = null;
        let isHost = false;
        let isReady = false;
        let roomPlayers = [];
        let myPlayerSlot = null; // 'p1' or 'p2'
        
        // New lobby state
        let playerName = '';
        let isPublicRoom = true;
        let roomName = '';
        let publicRooms = [];
        
        // Stability features
        let reconnectToken = null;
        let reconnectAttempts = 0;
        let reconnectTimer = null;
        let heartbeatTimer = null;
        let lastServerTime = 0;
        let messageQueue = [];
        let isReconnecting = false;

        // ‚ö†Ô∏è IMPORTANT: Replace with your Railway WebSocket URL
        // Format: wss://your-app-name.up.railway.app
        const WS_URL = 'wss://azuretme.up.railway.app';
        
        // Stability settings
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY_BASE = 1000;
        const HEARTBEAT_INTERVAL = 25000;

        const players = {
            p1: { board: null, piece: null, piecePos: null, nextPiece: null, score: 0, garbage: 0, dropTimer: null, lastRotationWasKick: false, lastMoveWasRotation: false },
            p2: { board: null, piece: null, piecePos: null, nextPiece: null, score: 0, garbage: 0, dropTimer: null, lastRotationWasKick: false, lastMoveWasRotation: false }
        };

        // ===== Audio =====
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playTone(freq, dur = 0.1, type = 'sine') {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + dur);
            } catch(e) {}
        }

        function playAttackSound() {
            playTone(200, 0.15, 'sawtooth');
            setTimeout(() => playTone(150, 0.1, 'square'), 50);
        }

        // ===== Error Toast =====
        function showError(msg) {
            const toast = document.getElementById('errorToast');
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
        
        function showInfo(msg) {
            const toast = document.getElementById('errorToast');
            toast.textContent = msg;
            toast.style.background = 'rgba(59, 130, 246, 0.9)';
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
                toast.style.background = '';
            }, 3000);
        }

        // ===== WebSocket with Auto-Reconnect =====
        function connectWebSocket(isReconnect = false) {
            return new Promise((resolve, reject) => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    resolve();
                    return;
                }

                // Clear existing connection
                if (ws) {
                    ws.onclose = null;
                    ws.onerror = null;
                    ws.close();
                }

                updateConnectionStatus(isReconnect ? 'reconnecting' : 'connecting');
                
                try {
                    ws = new WebSocket(WS_URL);
                } catch (e) {
                    console.error('Failed to create WebSocket:', e);
                    updateConnectionStatus('error');
                    reject(e);
                    return;
                }

                const connectionTimeout = setTimeout(() => {
                    if (ws && ws.readyState !== WebSocket.OPEN) {
                        ws.close();
                        reject(new Error('Connection timeout'));
                    }
                }, 10000);

                ws.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log('[WS] Connected');
                    updateConnectionStatus('connected');
                    reconnectAttempts = 0;
                    startHeartbeat();
                };

                ws.onmessage = (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        handleServerMessage(msg);
                        if (msg.type === 'connected') {
                            // Try to reconnect to room if we have a token
                            if (isReconnect && reconnectToken) {
                                sendMessage({ type: 'reconnect', reconnectToken });
                            }
                            resolve();
                        }
                    } catch (e) {
                        console.error('[WS] Failed to parse message:', e);
                    }
                };

                ws.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('[WS] Error:', error);
                    updateConnectionStatus('error');
                };

                ws.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('[WS] Closed:', event.code, event.reason);
                    stopHeartbeat();
                    updateConnectionStatus('disconnected');
                    ws = null;
                    
                    // Auto-reconnect if we were in a game or room
                    if ((roomCode || gameRunning) && !isReconnecting) {
                        attemptReconnect();
                    }
                    
                    if (!isReconnect) {
                        reject(new Error('Connection closed'));
                    }
                };
            });
        }

        function attemptReconnect() {
            if (isReconnecting || reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                    showError('Êé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü„ÄÇÂÜçÊé•Á∂ö„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ');
                    handleDisconnectDuringGame();
                }
                return;
            }

            isReconnecting = true;
            reconnectAttempts++;
            
            const delay = RECONNECT_DELAY_BASE * Math.pow(2, reconnectAttempts - 1);
            console.log(\`[WS] Reconnecting in \${delay}ms (attempt \${reconnectAttempts}/\${MAX_RECONNECT_ATTEMPTS})\`);
            showInfo(\`ÂÜçÊé•Á∂ö‰∏≠... (\${reconnectAttempts}/\${MAX_RECONNECT_ATTEMPTS})\`);

            reconnectTimer = setTimeout(async () => {
                try {
                    await connectWebSocket(true);
                    isReconnecting = false;
                    showInfo('ÂÜçÊé•Á∂ö„Åó„Åæ„Åó„Åü');
                    flushMessageQueue();
                } catch (e) {
                    isReconnecting = false;
                    attemptReconnect();
                }
            }, delay);
        }

        function handleDisconnectDuringGame() {
            if (gameRunning && isOnline) {
                // End game due to connection loss
                gameRunning = false;
                clearInterval(players.p1?.dropTimer);
                clearInterval(players.p2?.dropTimer);
                showError('Êé•Á∂ö„ÅåÂàá„Çå„Åæ„Åó„Åü');
            }
        }

        function startHeartbeat() {
            stopHeartbeat();
            heartbeatTimer = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Respond to server pings with pong
                    // The server sends ping, we respond with pong
                }
            }, HEARTBEAT_INTERVAL);
        }

        function stopHeartbeat() {
            if (heartbeatTimer) {
                clearInterval(heartbeatTimer);
                heartbeatTimer = null;
            }
        }

        function sendMessage(msg) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify(msg));
                    return true;
                } catch (e) {
                    console.error('[WS] Send failed:', e);
                    queueMessage(msg);
                    return false;
                }
            } else {
                queueMessage(msg);
                return false;
            }
        }

        function queueMessage(msg) {
            // Only queue important messages
            if (msg.type === 'relay' || msg.type === 'set_ready') {
                messageQueue.push({ msg, timestamp: Date.now() });
                // Limit queue size
                if (messageQueue.length > 50) {
                    messageQueue.shift();
                }
            }
        }

        function flushMessageQueue() {
            const now = Date.now();
            // Only send messages from last 10 seconds
            const validMessages = messageQueue.filter(m => now - m.timestamp < 10000);
            messageQueue = [];
            
            validMessages.forEach(m => {
                sendMessage(m.msg);
            });
        }

        function handleServerMessage(msg) {
            switch (msg.type) {
                case 'ping':
                    // Respond to server heartbeat
                    sendMessage({ type: 'pong' });
                    break;

                case 'connected':
                    myPlayerId = msg.playerId;
                    if (msg.serverTime) {
                        lastServerTime = msg.serverTime;
                    }
                    console.log('[WS] My player ID:', myPlayerId);
                    break;

                case 'room_created':
                    roomCode = msg.roomCode;
                    isHost = true;
                    if (msg.reconnectToken) {
                        reconnectToken = msg.reconnectToken;
                    }
                    showWaitingRoom();
                    break;

                case 'joined_room':
                    roomCode = msg.roomCode;
                    isHost = false;
                    if (msg.reconnectToken) {
                        reconnectToken = msg.reconnectToken;
                    }
                    showWaitingRoom();
                    break;

                case 'reconnected':
                    roomCode = msg.roomCode;
                    if (msg.reconnectToken) {
                        reconnectToken = msg.reconnectToken;
                    }
                    if (msg.roomState) {
                        updateRoomState(msg.roomState);
                    }
                    showInfo('„É´„Éº„É†„Å´ÂÜçÊé•Á∂ö„Åó„Åæ„Åó„Åü');
                    break;

                case 'room_state':
                    updateRoomState(msg.roomState);
                    break;

                case 'room_list':
                    renderRoomList(msg.rooms);
                    break;

                case 'player_joined':
                    playTone(880, 0.1, 'triangle');
                    break;

                case 'player_left':
                    playTone(220, 0.2, 'sawtooth');
                    if (gameRunning && isOnline) {
                        // Opponent left during game - you win!
                        showInfo('Áõ∏Êâã„ÅåÂàáÊñ≠„Åó„Åæ„Åó„Åü');
                        setTimeout(() => endBattle(myPlayerSlot), 1000);
                    }
                    break;

                case 'player_ready':
                    updatePlayerReady(msg.playerId, msg.ready);
                    break;

                case 'game_started':
                    startOnlineBattle(msg.gameSeed);
                    break;

                case 'relayed':
                    handleRelayedMessage(msg.fromPlayerId, msg.payload);
                    break;

                case 'sync_request':
                    // Other player is requesting state sync
                    if (gameRunning && isOnline && myPlayerSlot) {
                        sendBoardUpdate(myPlayerSlot);
                        sendNextUpdate(myPlayerSlot);
                    }
                    break;

                case 'server_shutdown':
                    showError('„Çµ„Éº„Éê„Éº„ÅåÂÜçËµ∑Âãï‰∏≠„Åß„Åô„ÄÇ„Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    break;

                case 'error':
                    showError(msg.message);
                    break;
            }
        }

        function handleRelayedMessage(fromPlayerId, payload) {
            if (!isOnline || !gameRunning) return;

            const opponentSlot = myPlayerSlot === 'p1' ? 'p2' : 'p1';

            switch (payload.type) {
                case 'board_update':
                    players[opponentSlot].board = payload.board;
                    players[opponentSlot].piece = payload.piece;
                    players[opponentSlot].piecePos = payload.piecePos;
                    players[opponentSlot].score = payload.score;
                    drawBoard(opponentSlot, opponentSlot + 'Board');
                    updateScores();
                    break;

                case 'next_update':
                    players[opponentSlot].nextPiece = payload.nextPiece;
                    drawNext(opponentSlot, opponentSlot + 'Next');
                    break;

                case 'garbage_sent':
                    players[myPlayerSlot].garbage += payload.lines;
                    document.getElementById(myPlayerSlot + 'Garbage').style.height = 
                        Math.min(players[myPlayerSlot].garbage * 5, 100) + '%';
                    showAttack(myPlayerSlot, payload.lines);
                    playAttackSound();
                    document.getElementById(opponentSlot + 'BoardWrap').classList.add('attack');
                    setTimeout(() => document.getElementById(opponentSlot + 'BoardWrap').classList.remove('attack'), 300);
                    break;

                case 'game_over':
                    endBattle(myPlayerSlot);
                    break;
            }
        }

        function updateConnectionStatus(status) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            if (!dot || !text) return;
            
            dot.className = 'status-dot';
            
            switch (status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = 'Êé•Á∂öÊ∏à„Åø';
                    break;
                case 'connecting':
                    dot.classList.add('connecting');
                    text.textContent = 'Êé•Á∂ö‰∏≠...';
                    break;
                case 'reconnecting':
                    dot.classList.add('connecting');
                    text.textContent = 'ÂÜçÊé•Á∂ö‰∏≠...';
                    break;
                case 'error':
                case 'disconnected':
                    dot.classList.add('error');
                    text.textContent = 'Êú™Êé•Á∂ö';
                    break;
            }
        }

        // ===== Online Lobby =====
        // ===== Online Lobby UI =====
        async function showOnlineLobby() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('onlineLobby').classList.add('active');
            
            // Reset state
            reconnectAttempts = 0;
            isReconnecting = false;
            
            // Show name entry screen first
            document.getElementById('nameEntryScreen').classList.remove('hidden');
            document.getElementById('roomBrowserScreen').classList.remove('active');
            
            // Load saved name if exists
            const savedName = localStorage.getItem('rhythmia_player_name') || '';
            document.getElementById('playerNameInput').value = savedName;
            
            try {
                await connectWebSocket();
            } catch (e) {
                showError('„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇURL„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
        }

        function submitPlayerName() {
            const nameInput = document.getElementById('playerNameInput');
            const name = nameInput.value.trim();
            
            if (!name) {
                showError('ÂêçÂâç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                nameInput.focus();
                return;
            }
            
            playerName = name;
            localStorage.setItem('rhythmia_player_name', name);
            
            // Hide name entry, show room browser
            document.getElementById('nameEntryScreen').classList.add('hidden');
            document.getElementById('roomBrowserScreen').classList.add('active');
            document.getElementById('displayPlayerName').textContent = playerName;
            
            // Auto-refresh room list
            refreshRoomList();
            
            playTone(880, 0.1, 'triangle');
        }

        function editPlayerName() {
            document.getElementById('roomBrowserScreen').classList.remove('active');
            document.getElementById('nameEntryScreen').classList.remove('hidden');
            document.getElementById('playerNameInput').focus();
        }

        function switchTab(tab) {
            // Update tab buttons
            document.getElementById('tabCreate').classList.toggle('active', tab === 'create');
            document.getElementById('tabList').classList.toggle('active', tab === 'list');
            
            // Update tab panes
            document.getElementById('paneCreate').classList.toggle('active', tab === 'create');
            document.getElementById('paneList').classList.toggle('active', tab === 'list');
            
            if (tab === 'list') {
                refreshRoomList();
            }
            
            playTone(523, 0.05);
        }

        function togglePublic() {
            isPublicRoom = !isPublicRoom;
            document.getElementById('publicToggle').classList.toggle('active', isPublicRoom);
        }

        function refreshRoomList() {
            const listEl = document.getElementById('roomList');
            listEl.innerHTML = '<div class="room-list-empty">„É´„Éº„É†„ÇíÊ§úÁ¥¢‰∏≠...</div>';
            
            // Request room list from server
            sendMessage({ type: 'get_rooms' });
        }

        function renderRoomList(rooms) {
            const listEl = document.getElementById('roomList');
            publicRooms = rooms || [];
            
            if (publicRooms.length === 0) {
                listEl.innerHTML = '<div class="room-list-empty">ÂÖ¨Èñã„É´„Éº„É†„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }
            
            listEl.innerHTML = publicRooms.map(room => \`
                <div class="room-item" onclick="joinRoomFromList('\${room.code}')">
                    <div class="room-item-info">
                        <div class="room-item-name">\${escapeHtml(room.name || '„Éê„Éà„É´„É´„Éº„É†')}</div>
                        <div class="room-item-host">„Éõ„Çπ„Éà: \${escapeHtml(room.hostName || 'Player')}</div>
                    </div>
                    <div class="room-item-players">
                        üë• \${room.playerCount}/2
                    </div>
                </div>
            \`).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function backToMainLobby() {
            // Clean up
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
            stopHeartbeat();
            isReconnecting = false;
            reconnectAttempts = 0;
            reconnectToken = null;
            roomCode = null;
            
            // Reset UI state
            document.getElementById('nameEntryScreen').classList.remove('hidden');
            document.getElementById('roomBrowserScreen').classList.remove('active');
            
            document.getElementById('onlineLobby').classList.remove('active');
            document.getElementById('waitingRoom').classList.remove('active');
            document.getElementById('lobby').style.display = 'flex';
            
            if (ws) {
                ws.close();
            }
        }

        async function createRoom() {
            roomName = document.getElementById('roomNameInput').value.trim() || '„Éê„Éà„É´„É´„Éº„É†';
            
            try {
                await connectWebSocket();
                sendMessage({ 
                    type: 'create_room', 
                    playerName: playerName,
                    roomName: roomName,
                    isPublic: isPublicRoom
                });
            } catch (e) {
                showError('Êé•Á∂ö„Ç®„É©„Éº');
            }
        }

        async function joinRoomByCode() {
            const code = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            
            if (code.length !== 4) {
                showError('4ÊñáÂ≠ó„ÅÆ„É´„Éº„É†„Ç≥„Éº„Éâ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            try {
                await connectWebSocket();
                sendMessage({ type: 'join_room', roomCode: code, playerName: playerName });
            } catch (e) {
                showError('Êé•Á∂ö„Ç®„É©„Éº');
            }
        }

        async function joinRoomFromList(code) {
            try {
                await connectWebSocket();
                sendMessage({ type: 'join_room', roomCode: code, playerName: playerName });
            } catch (e) {
                showError('Êé•Á∂ö„Ç®„É©„Éº');
            }
        }

        // Keep for backwards compatibility
        async function joinRoom() {
            await joinRoomByCode();
        }

        function showWaitingRoom() {
            document.getElementById('onlineLobby').classList.remove('active');
            document.getElementById('waitingRoom').classList.add('active');
            document.getElementById('displayRoomCode').textContent = roomCode;
            
            isReady = false;
            updateReadyButton();
        }

        function updateRoomState(state) {
            roomPlayers = state.players || [];
            
            // Update player slots
            const slot1 = document.getElementById('slot1');
            const slot2 = document.getElementById('slot2');
            
            roomPlayers.forEach((player, index) => {
                const slot = index === 0 ? slot1 : slot2;
                const slotName = slot.querySelector('.player-slot-name');
                const slotStatus = slot.querySelector('.player-slot-status');
                
                slotName.textContent = player.name;
                slotStatus.textContent = player.ready ? 'Ê∫ñÂÇôÂÆå‰∫Ü' : 'ÂæÖÊ©ü‰∏≠';
                slot.classList.toggle('ready', player.ready);

                if (player.id === myPlayerId) {
                    myPlayerSlot = index === 0 ? 'p1' : 'p2';
                }
            });

            // Reset empty slots
            if (roomPlayers.length < 2) {
                const emptySlot = roomPlayers.length === 0 ? slot1 : slot2;
                emptySlot.querySelector('.player-slot-name').textContent = 'ÂæÖÊ©ü‰∏≠...';
                emptySlot.querySelector('.player-slot-status').textContent = '---';
                emptySlot.classList.remove('ready');
            }

            // Update start button
            const canStart = isHost && roomPlayers.length === 2 && roomPlayers.every(p => p.ready);
            document.getElementById('startGameBtn').disabled = !canStart;
        }

        function updatePlayerReady(playerId, ready) {
            const player = roomPlayers.find(p => p.id === playerId);
            if (player) {
                player.ready = ready;
            }
        }

        function toggleReady() {
            isReady = !isReady;
            sendMessage({ type: 'set_ready', ready: isReady });
            updateReadyButton();
        }

        function updateReadyButton() {
            const btn = document.getElementById('readyBtn');
            btn.className = 'ready-btn ' + (isReady ? 'is-ready' : 'not-ready');
            btn.textContent = isReady ? '‚úó „Ç≠„É£„É≥„Çª„É´' : '‚úì Ê∫ñÂÇôÂÆå‰∫Ü';
        }

        function leaveRoom() {
            sendMessage({ type: 'leave_room' });
            roomCode = null;
            isHost = false;
            isReady = false;
            document.getElementById('waitingRoom').classList.remove('active');
            document.getElementById('onlineLobby').classList.add('active');
        }

        function startOnlineGame() {
            if (!isHost) return;
            sendMessage({ type: 'start_game' });
        }

        // Piece type identifiers for multiplayer
        const PIECE_TYPES_MP = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];

        // SRS Wall Kick Data for JLSTZ pieces (multiplayer)
        const WALL_KICKS_MP = {
            '0>1': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '1>0': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '1>2': [[0,0], [1,0], [1,1], [0,-2], [1,-2]],
            '2>1': [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]],
            '2>3': [[0,0], [1,0], [1,-1], [0,2], [1,2]],
            '3>2': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '3>0': [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]],
            '0>3': [[0,0], [1,0], [1,-1], [0,2], [1,2]]
        };

        // SRS Wall Kick Data for I piece (multiplayer)
        const I_WALL_KICKS_MP = {
            '0>1': [[0,0], [-2,0], [1,0], [-2,1], [1,-2]],
            '1>0': [[0,0], [2,0], [-1,0], [2,-1], [-1,2]],
            '1>2': [[0,0], [-1,0], [2,0], [-1,-2], [2,1]],
            '2>1': [[0,0], [1,0], [-2,0], [1,2], [-2,-1]],
            '2>3': [[0,0], [2,0], [-1,0], [2,-1], [-1,2]],
            '3>2': [[0,0], [-2,0], [1,0], [-2,1], [1,-2]],
            '3>0': [[0,0], [1,0], [-2,0], [1,2], [-2,-1]],
            '0>3': [[0,0], [-1,0], [2,0], [-1,-2], [2,1]]
        };

        // ===== Game Logic =====
        function randomPiece() {
            const shapeIdx = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[shapeIdx].map(row => [...row]); // Deep copy
            const color = COLORS[Math.floor(Math.random() * COLORS.length)];
            const type = PIECE_TYPES_MP[shapeIdx];
            return { shape, color, type, rotation: 0 };
        }

        function createBoard(id) {
            const el = document.getElementById(id);
            el.innerHTML = '';
            el.style.gridTemplateColumns = \`repeat(\${W}, 1fr)\`;
            for (let i = 0; i < W * H; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                el.appendChild(cell);
            }
        }

        function drawBoard(player, boardId) {
            const p = players[player];
            if (!p.board) return;
            
            const cells = document.getElementById(boardId).children;
            const display = p.board.map(r => [...r]);

            if (p.piece) {
                let gy = p.piecePos.y;
                while (!collision(p, p.piece, p.piecePos.x, gy + 1)) gy++;
                p.piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = gy + py, bx = p.piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W && !display[by][bx]) {
                                display[by][bx] = { color: p.piece.color, ghost: true };
                            }
                        }
                    });
                });

                p.piece.shape.forEach((row, py) => {
                    row.forEach((val, px) => {
                        if (val) {
                            const by = p.piecePos.y + py, bx = p.piecePos.x + px;
                            if (by >= 0 && by < H && bx >= 0 && bx < W) {
                                display[by][bx] = { color: p.piece.color };
                            }
                        }
                    });
                });
            }

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const cell = cells[y * W + x];
                    const val = display[y][x];
                    if (val) {
                        cell.className = 'cell filled' + (val.ghost ? ' ghost' : '') + (val.garbage ? ' garbage' : '');
                        cell.style.backgroundColor = val.garbage ? '#666' : val.color;
                        cell.style.color = val.garbage ? '#666' : val.color;
                    } else {
                        cell.className = 'cell';
                        cell.style.backgroundColor = '';
                        cell.style.color = '';
                    }
                }
            }
        }

        function drawNext(player, nextId) {
            const p = players[player];
            if (!p.nextPiece) return;
            const el = document.getElementById(nextId);
            el.innerHTML = '';
            el.style.gridTemplateColumns = \`repeat(\${p.nextPiece.shape[0].length}, 1fr)\`;
            p.nextPiece.shape.forEach(row => {
                row.forEach(val => {
                    const cell = document.createElement('div');
                    cell.className = 'next-cell';
                    if (val) {
                        cell.style.backgroundColor = p.nextPiece.color;
                        cell.style.boxShadow = \`0 0 6px \${p.nextPiece.color}\`;
                    }
                    el.appendChild(cell);
                });
            });
        }

        function collision(p, piece, x, y) {
            return piece.shape.some((row, py) =>
                row.some((val, px) => {
                    if (!val) return false;
                    const nx = x + px, ny = y + py;
                    return nx < 0 || nx >= W || ny >= H || (ny >= 0 && p.board[ny][nx]);
                })
            );
        }

        function rotate(piece, direction = 1) {
            const rotateShapeCW = (shape) => shape[0].map((_, i) => shape.map(row => row[i]).reverse());
            const rotateShapeCCW = (shape) => shape[0].map((_, i) => shape.map(row => row[row.length - 1 - i]));
            const newRotation = (piece.rotation + direction + 4) % 4;
            return {
                ...piece,
                shape: direction === 1 ? rotateShapeCW(piece.shape) : rotateShapeCCW(piece.shape),
                rotation: newRotation
            };
        }

        // Get wall kick data for multiplayer
        function getWallKicksMP(pieceType, fromRot, toRot) {
            const key = fromRot + '>' + toRot;
            if (pieceType === 'I') return I_WALL_KICKS_MP[key] || [[0,0]];
            if (pieceType === 'O') return [[0,0]]; // O piece doesn't need kicks
            return WALL_KICKS_MP[key] || [[0,0]];
        }

        // T-Spin detection for multiplayer
        function checkTSpinMP(player) {
            const p = players[player];
            if (!p.piece || p.piece.type !== 'T' || !p.lastMoveWasRotation) return 'none';
            
            // Check 4 corners of T piece center
            const cx = p.piecePos.x + 1;
            const cy = p.piecePos.y + 1;
            const corners = [
                [cx - 1, cy - 1], [cx + 1, cy - 1],
                [cx - 1, cy + 1], [cx + 1, cy + 1]
            ];
            
            let filledCorners = 0;
            let frontCorners = 0;
            
            corners.forEach(([x, y], i) => {
                const blocked = x < 0 || x >= W || y >= H || (y >= 0 && p.board[y] && p.board[y][x]);
                if (blocked) {
                    filledCorners++;
                    // Front corners based on rotation
                    const frontIdx = [[0,1], [1,3], [2,3], [0,2]][p.piece.rotation];
                    if (frontIdx.includes(i)) frontCorners++;
                }
            });
            
            if (filledCorners >= 3) {
                if (frontCorners >= 2 || p.lastRotationWasKick) return 'tspin';
                return 'mini';
            }
            return 'none';
        }

        function sendBoardUpdate(player) {
            if (!isOnline) return;
            const p = players[player];
            sendMessage({
                type: 'relay',
                payload: {
                    type: 'board_update',
                    board: p.board,
                    piece: p.piece,
                    piecePos: p.piecePos,
                    score: p.score
                }
            });
        }

        function sendNextUpdate(player) {
            if (!isOnline) return;
            const p = players[player];
            sendMessage({
                type: 'relay',
                payload: {
                    type: 'next_update',
                    nextPiece: p.nextPiece
                }
            });
        }

        function sendGarbage(lines) {
            if (!isOnline) return;
            sendMessage({
                type: 'relay',
                payload: {
                    type: 'garbage_sent',
                    lines: lines
                }
            });
        }

        function sendGameOver() {
            if (!isOnline) return;
            sendMessage({
                type: 'relay',
                payload: { type: 'game_over' }
            });
        }

        function lock(player, boardId, opponent) {
            const p = players[player];
            const opp = players[opponent];
            
            if (!p.piece) return;

            // Check T-Spin before locking piece
            const tSpinType = checkTSpinMP(player);

            p.piece.shape.forEach((row, py) => {
                row.forEach((val, px) => {
                    if (val) {
                        const by = p.piecePos.y + py, bx = p.piecePos.x + px;
                        if (by >= 0 && by < H) {
                            p.board[by][bx] = { color: p.piece.color };
                        }
                    }
                });
            });

            let cleared = 0;
            const newBoard = [];
            const clearingRows = [];

            p.board.forEach((row, y) => {
                if (row.every(c => c !== null)) {
                    cleared++;
                    clearingRows.push(y);
                } else {
                    newBoard.push(row);
                }
            });

            if (cleared > 0) {
                const cells = document.getElementById(boardId).children;
                clearingRows.forEach(y => {
                    for (let x = 0; x < W; x++) {
                        cells[y * W + x].classList.add('clearing');
                    }
                });

                setTimeout(() => {
                    while (newBoard.length < H) newBoard.unshift(Array(W).fill(null));
                    p.board = newBoard;

                    let pts = [0, 100, 300, 500, 800][cleared];
                    
                    // T-Spin bonuses
                    if (tSpinType === 'tspin') {
                        const tSpinClearedIndex = Math.min(cleared, 3);
                        const tSpinPts = [400, 800, 1200, 1600][tSpinClearedIndex];
                        pts += tSpinPts;
                    } else if (tSpinType === 'mini') {
                        const miniClearIndex = cleared <= 0 ? 0 : 1;
                        const miniPts = [100, 200][miniClearIndex];
                        pts += miniPts;
                    }
                    
                    p.score += pts;
                    updateScores();

                    // Send garbage to opponent
                    let garbageLines = 0;
                    if (cleared >= 2) {
                        garbageLines = cleared - 1;
                    }
                    
                    // T-Spin damage multiplier
                    let tSpinDamageMult = 1;
                    if (tSpinType === 'tspin') {
                        tSpinDamageMult = 1.5;
                    }
                    
                    if (garbageLines > 0) {
                        garbageLines = Math.floor(garbageLines * tSpinDamageMult);
                        
                        if (isOnline && player === myPlayerSlot) {
                            sendGarbage(garbageLines);
                        } else if (!isOnline) {
                            opp.garbage += garbageLines;
                            document.getElementById(opponent + 'Garbage').style.height = Math.min(opp.garbage * 5, 100) + '%';
                            showAttack(opponent, garbageLines);
                        }
                        
                        playAttackSound();
                        document.getElementById(player + 'BoardWrap').classList.add('attack');
                        setTimeout(() => document.getElementById(player + 'BoardWrap').classList.remove('attack'), 300);
                    }

                    drawBoard(player, boardId);
                    if (isOnline && player === myPlayerSlot) {
                        sendBoardUpdate(player);
                    }
                }, 300);
            } else if (tSpinType !== 'none') {
                // T-Spin with no lines still gives points
                let pts = 0;
                if (tSpinType === 'tspin') {
                    pts = 400;
                } else if (tSpinType === 'mini') {
                    pts = 100;
                }
                p.score += pts;
                updateScores();
            }

            // Reset rotation tracking
            p.lastMoveWasRotation = false;

            // Add garbage if pending
            if (p.garbage > 0) {
                addGarbage(player, boardId);
            }

            p.piece = p.nextPiece;
            p.nextPiece = randomPiece();
            p.piecePos = { x: Math.floor(W/2) - 1, y: 0 };
            drawNext(player, player + 'Next');
            drawBoard(player, boardId);

            if (isOnline && player === myPlayerSlot) {
                sendNextUpdate(player);
                sendBoardUpdate(player);
            }

            if (collision(p, p.piece, p.piecePos.x, p.piecePos.y)) {
                if (isOnline && player === myPlayerSlot) {
                    sendGameOver();
                }
                endBattle(opponent);
            }
        }

        function addGarbage(player, boardId) {
            const p = players[player];
            const linesToAdd = Math.min(p.garbage, 8);
            p.garbage = Math.max(0, p.garbage - linesToAdd);
            
            document.getElementById(player + 'Garbage').style.height = Math.min(p.garbage * 5, 100) + '%';
            
            p.board.splice(0, linesToAdd);
            
            const gapX = Math.floor(Math.random() * W);
            for (let i = 0; i < linesToAdd; i++) {
                const row = Array(W).fill(null).map((_, x) => x === gapX ? null : { color: '#666', garbage: true });
                p.board.push(row);
            }
            
            document.getElementById(player + 'BoardWrap').classList.add('damaged');
            setTimeout(() => document.getElementById(player + 'BoardWrap').classList.remove('damaged'), 400);
            
            playTone(100, 0.2, 'square');
        }

        function showAttack(target, lines) {
            const notif = document.getElementById('attackNotif');
            notif.textContent = '+' + lines + ' GARBAGE!';
            notif.className = 'attack-notification show';
            setTimeout(() => notif.className = 'attack-notification', 800);
        }

        function move(player, boardId, opponent, dx, dy) {
            if (!gameRunning) return;
            const p = players[player];
            if (!p.piece) return;

            if (!collision(p, p.piece, p.piecePos.x + dx, p.piecePos.y + dy)) {
                p.piecePos.x += dx;
                p.piecePos.y += dy;
                p.lastMoveWasRotation = false;
                if (dx !== 0) playTone(392, 0.03, 'square');
                drawBoard(player, boardId);
                if (isOnline && player === myPlayerSlot) {
                    sendBoardUpdate(player);
                }
            } else if (dy > 0) {
                lock(player, boardId, opponent);
            }
        }

        function rotatePiece(player, boardId, direction = 1) {
            if (!gameRunning) return;
            const p = players[player];
            if (!p.piece) return;

            const fromRot = p.piece.rotation;
            const rotated = rotate(p.piece, direction);
            const toRot = rotated.rotation;
            const kicks = getWallKicksMP(p.piece.type, fromRot, toRot);
            
            for (let i = 0; i < kicks.length; i++) {
                const [dx, dy] = kicks[i];
                if (!collision(p, rotated, p.piecePos.x + dx, p.piecePos.y - dy)) {
                    p.piece = rotated;
                    p.piecePos.x += dx;
                    p.piecePos.y -= dy;
                    p.lastRotationWasKick = (i > 0);
                    p.lastMoveWasRotation = true;
                    playTone(523, 0.05);
                    drawBoard(player, boardId);
                    if (isOnline && player === myPlayerSlot) {
                        sendBoardUpdate(player);
                    }
                    return;
                }
            }
        }

        function rotatePieceLeft(player, boardId) {
            rotatePiece(player, boardId, -1);
        }

        function rotatePieceRight(player, boardId) {
            rotatePiece(player, boardId, 1);
        }

        function hardDrop(player, boardId, opponent) {
            if (!gameRunning) return;
            const p = players[player];
            if (!p.piece) return;

            while (!collision(p, p.piece, p.piecePos.x, p.piecePos.y + 1)) {
                p.piecePos.y++;
            }
            p.lastMoveWasRotation = false;
            playTone(196, 0.08, 'sawtooth');
            drawBoard(player, boardId);
            lock(player, boardId, opponent);
        }

        function updateScores() {
            document.getElementById('p1Score').textContent = players.p1.score;
            document.getElementById('p2Score').textContent = players.p2.score;
        }

        function initPlayer(player) {
            players[player] = {
                board: Array(H).fill().map(() => Array(W).fill(null)),
                piece: randomPiece(),
                piecePos: { x: Math.floor(W/2) - 1, y: 0 },
                nextPiece: randomPiece(),
                score: 0,
                garbage: 0,
                dropTimer: null,
                lastRotationWasKick: false,
                lastMoveWasRotation: false
            };
        }

        function startBattle(mode) {
            lastMode = mode;
            isAI = mode === 'ai';
            isOnline = false;
            
            initAudio();
            
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('battleContainer').classList.add('active');
            document.getElementById('resultOverlay').classList.remove('show');
            document.getElementById('controlsHint').style.display = 'flex';
            
            document.getElementById('p1NameDisplay').textContent = 'PLAYER 1';
            document.getElementById('p2NameDisplay').textContent = isAI ? 'CPU' : 'PLAYER 2';
            
            initPlayer('p1');
            initPlayer('p2');
            
            createBoard('p1Board');
            createBoard('p2Board');
            
            drawBoard('p1', 'p1Board');
            drawBoard('p2', 'p2Board');
            drawNext('p1', 'p1Next');
            drawNext('p2', 'p2Next');
            updateScores();
            
            document.getElementById('p1Garbage').style.height = '0%';
            document.getElementById('p2Garbage').style.height = '0%';
            
            runCountdown(() => {
                gameRunning = true;
                startDropTimers();
                if (isAI) startAI();
            });
        }

        function startOnlineBattle(gameSeed) {
            isOnline = true;
            isAI = false;
            lastMode = 'online';
            
            initAudio();
            
            // Use game seed for deterministic piece generation if provided
            if (gameSeed) {
                console.log('[GAME] Starting with seed:', gameSeed);
            }
            
            document.getElementById('waitingRoom').classList.remove('active');
            document.getElementById('battleContainer').classList.add('active');
            document.getElementById('resultOverlay').classList.remove('show');
            
            // Hide P2 controls hint in online mode
            document.getElementById('controlsHint').innerHTML = \`
                <div class="control-group">
                    <span>Controls</span>
                    <div class="key-hint">
                        <span class="key">A/‚Üê</span>
                        <span class="key">S/‚Üì</span>
                        <span class="key">D/‚Üí</span>
                        <span class="key">W/‚Üë</span>
                        <span class="key">Space</span>
                    </div>
                </div>
            \`;

            // Set player names
            const p1Player = roomPlayers[0];
            const p2Player = roomPlayers[1];
            document.getElementById('p1NameDisplay').textContent = p1Player?.name || 'PLAYER 1';
            document.getElementById('p2NameDisplay').textContent = p2Player?.name || 'PLAYER 2';
            
            initPlayer('p1');
            initPlayer('p2');
            
            createBoard('p1Board');
            createBoard('p2Board');
            
            drawBoard('p1', 'p1Board');
            drawBoard('p2', 'p2Board');
            drawNext('p1', 'p1Next');
            drawNext('p2', 'p2Next');
            updateScores();
            
            document.getElementById('p1Garbage').style.height = '0%';
            document.getElementById('p2Garbage').style.height = '0%';
            
            // Send initial state
            sendBoardUpdate(myPlayerSlot);
            sendNextUpdate(myPlayerSlot);
            
            runCountdown(() => {
                gameRunning = true;
                // Only run drop timer for my player in online mode
                const opponent = myPlayerSlot === 'p1' ? 'p2' : 'p1';
                players[myPlayerSlot].dropTimer = setInterval(() => {
                    if (gameRunning && !isReconnecting) {
                        move(myPlayerSlot, myPlayerSlot + 'Board', opponent, 0, 1);
                    }
                }, 500);
            });
        }

        function runCountdown(callback) {
            const countdown = document.getElementById('countdown');
            let count = 3;
            countdown.textContent = count;
            countdown.style.display = 'block';
            
            const countInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdown.textContent = count;
                    playTone(440, 0.1);
                } else if (count === 0) {
                    countdown.textContent = 'GO!';
                    playTone(880, 0.2, 'triangle');
                } else {
                    clearInterval(countInterval);
                    countdown.style.display = 'none';
                    callback();
                }
            }, 1000);
        }

        function startDropTimers() {
            players.p1.dropTimer = setInterval(() => {
                if (gameRunning) move('p1', 'p1Board', 'p2', 0, 1);
            }, 500);
            
            players.p2.dropTimer = setInterval(() => {
                if (gameRunning) move('p2', 'p2Board', 'p1', 0, 1);
            }, isAI ? 600 : 500);
        }

        function startAI() {
            aiTimer = setInterval(() => {
                if (!gameRunning || !players.p2.piece) return;
                
                const action = Math.random();
                if (action < 0.3) {
                    move('p2', 'p2Board', 'p1', -1, 0);
                } else if (action < 0.6) {
                    move('p2', 'p2Board', 'p1', 1, 0);
                } else if (action < 0.8) {
                    rotatePiece('p2', 'p2Board');
                } else if (action < 0.95) {
                    move('p2', 'p2Board', 'p1', 0, 1);
                } else {
                    hardDrop('p2', 'p2Board', 'p1');
                }
            }, 150);
        }

        function endBattle(winner) {
            gameRunning = false;
            clearInterval(players.p1.dropTimer);
            clearInterval(players.p2.dropTimer);
            if (aiTimer) clearInterval(aiTimer);
            
            let winnerName;
            if (isOnline) {
                const winnerPlayer = winner === 'p1' ? roomPlayers[0] : roomPlayers[1];
                winnerName = winnerPlayer?.name || (winner === 'p1' ? 'PLAYER 1' : 'PLAYER 2');
            } else {
                winnerName = winner === 'p1' ? 'PLAYER 1' : (isAI ? 'CPU' : 'PLAYER 2');
            }
            
            const winnerText = document.getElementById('winnerText');
            winnerText.textContent = winnerName + ' WINS!';
            winnerText.className = 'winner-display ' + winner;
            
            document.getElementById('finalP1').textContent = players.p1.score;
            document.getElementById('finalP2').textContent = players.p2.score;
            
            setTimeout(() => {
                document.getElementById('resultOverlay').classList.add('show');
                spawnFireworks();
            }, 500);
            
            [523, 659, 784, 1047].forEach((f, i) => {
                setTimeout(() => playTone(f, 0.2, 'triangle'), i * 100);
            });
        }

        function spawnFireworks() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const fw = document.createElement('div');
                    fw.className = 'firework';
                    fw.style.cssText = \`
                        left: \${Math.random() * 100}vw;
                        top: \${Math.random() * 60}vh;
                        width: 10px;
                        height: 10px;
                        background: hsl(\${Math.random() * 360}, 100%, 60%);
                        border-radius: 50%;
                        box-shadow: 0 0 20px currentColor;
                        animation: fireworkPop 1s ease-out forwards;
                    \`;
                    document.body.appendChild(fw);
                    setTimeout(() => fw.remove(), 1000);
                }, i * 100);
            }
        }

        function handleRematch() {
            if (isOnline) {
                // For online, go back to waiting room
                document.getElementById('battleContainer').classList.remove('active');
                document.getElementById('resultOverlay').classList.remove('show');
                isReady = false;
                updateReadyButton();
                showWaitingRoom();
            } else {
                startBattle(lastMode);
            }
        }

        function backToLobby() {
            document.getElementById('battleContainer').classList.remove('active');
            document.getElementById('resultOverlay').classList.remove('show');
            
            if (isOnline) {
                sendMessage({ type: 'leave_room' });
                roomCode = null;
                isHost = false;
                isReady = false;
                backToMainLobby();
            } else {
                document.getElementById('lobby').style.display = 'flex';
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', e => {
            if (!gameRunning) return;
            
            if (isOnline) {
                // Online mode - control only my player
                const opponent = myPlayerSlot === 'p1' ? 'p2' : 'p1';
                const boardId = myPlayerSlot + 'Board';
                
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') {
                    move(myPlayerSlot, boardId, opponent, -1, 0);
                } else if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') {
                    move(myPlayerSlot, boardId, opponent, 1, 0);
                } else if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') {
                    move(myPlayerSlot, boardId, opponent, 0, 1);
                } else if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') {
                    rotatePieceRight(myPlayerSlot, boardId);
                } else if (e.key === 'q' || e.key === 'Q' || e.key === 'z' || e.key === 'Z') {
                    rotatePieceLeft(myPlayerSlot, boardId);
                } else if (e.key === 'e' || e.key === 'E' || e.key === 'x' || e.key === 'X') {
                    rotatePieceRight(myPlayerSlot, boardId);
                } else if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    hardDrop(myPlayerSlot, boardId, opponent);
                }
            } else {
                // Local mode
                // P1: WASD + QE + Space
                if (e.key === 'a' || e.key === 'A') move('p1', 'p1Board', 'p2', -1, 0);
                else if (e.key === 'd' || e.key === 'D') move('p1', 'p1Board', 'p2', 1, 0);
                else if (e.key === 's' || e.key === 'S') move('p1', 'p1Board', 'p2', 0, 1);
                else if (e.key === 'w' || e.key === 'W') rotatePieceRight('p1', 'p1Board');
                else if (e.key === 'q' || e.key === 'Q') rotatePieceLeft('p1', 'p1Board');
                else if (e.key === 'e' || e.key === 'E') rotatePieceRight('p1', 'p1Board');
                else if (e.key === ' ') { e.preventDefault(); hardDrop('p1', 'p1Board', 'p2'); }
                
                // P2: Arrows + ZX + Enter (only if not AI)
                if (!isAI) {
                    if (e.key === 'ArrowLeft') move('p2', 'p2Board', 'p1', -1, 0);
                    else if (e.key === 'ArrowRight') move('p2', 'p2Board', 'p1', 1, 0);
                    else if (e.key === 'ArrowDown') move('p2', 'p2Board', 'p1', 0, 1);
                    else if (e.key === 'ArrowUp') rotatePieceRight('p2', 'p2Board');
                    else if (e.key === 'z') rotatePieceLeft('p2', 'p2Board');
                    else if (e.key === 'x') rotatePieceRight('p2', 'p2Board');
                    else if (e.key === 'Enter') { e.preventDefault(); hardDrop('p2', 'p2Board', 'p1'); }
                }
            }
        });

        // Enter key handlers for lobby inputs
        document.getElementById('playerNameInput')?.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitPlayerName();
            }
        });

        document.getElementById('roomCodeInput')?.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                joinRoomByCode();
            }
        });

        document.getElementById('roomNameInput')?.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                createRoom();
            }
        });

        // Add firework animation
        const style = document.createElement('style');
        style.textContent = \`
            @keyframes fireworkPop {
                0% { transform: scale(1); opacity: 1; }
                100% { transform: scale(3); opacity: 0; }
            }
        \`;
        document.head.appendChild(style);
    <\/script>
</body>
</html>`;

        // Modded game HTML (Life Journey) - same as before
        gameContent.modded = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIFE JOURNEY</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"><\/script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"><\/script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"><\/script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { min-height: 100vh; }
        #root { min-height: 100vh; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState } = React;

        const chapters = [
          {
            id: 'birth',
            title: 'Ë™ïÁîü',
            subtitle: 'Genesis',
            color: '#FFE4E1',
            accent: '#FF6B6B',
            emoji: 'üåÖ',
            poem: 'ÂÖâ„ÅÆ‰∏≠„Å∏',
            description: 'ÁÑ°Èôê„ÅÆÂèØËÉΩÊÄß„ÇíÊä±„ÅÑ„Å¶„ÄÅ„Åì„ÅÆ‰∏ñÁïå„Å´Áîü„Åæ„ÇåËêΩ„Å°„ÇãÁû¨Èñì„ÄÇ„Åô„Åπ„Å¶„ÅåÊñ∞„Åó„Åè„ÄÅ„Åô„Åπ„Å¶„ÅåÁú©„Åó„ÅÑ„ÄÇ',
            visual: 'radial-gradient(ellipse at 50% 100%, #FFB6C1 0%, #FFE4E1 40%, #FFF8DC 100%)'
          },
          {
            id: 'growth',
            title: 'ÊàêÈï∑',
            subtitle: 'Bloom',
            color: '#E8F5E9',
            accent: '#4CAF50',
            emoji: 'üå±',
            poem: 'Ê†π„ÇíÂºµ„Çä„ÄÅÁ©∫„Å∏',
            description: 'Â∞è„Åï„Å™ËäΩ„ÅåÂúü„ÇíÁ†¥„Çä„ÄÅÂ§™ÈôΩ„Å´Âêë„Åã„Å£„Å¶‰º∏„Å≥„Å¶„ÅÑ„Åè„ÄÇÂ•ΩÂ•áÂøÉ„Å®Áô∫Ë¶ã„ÅÆÊó•„ÄÖ„ÄÇ',
            visual: 'linear-gradient(180deg, #87CEEB 0%, #E8F5E9 50%, #8B4513 100%)'
          },
          {
            id: 'adventure',
            title: 'ÂÜíÈô∫',
            subtitle: 'Journey',
            color: '#E3F2FD',
            accent: '#2196F3',
            emoji: '‚õµ',
            poem: 'Êú™Áü•„Å™„ÇãÊµ∑„Å∏',
            description: 'Â∫É„ÅÑ‰∏ñÁïå„Å´È£õ„Å≥Âá∫„Åó„ÄÅËá™ÂàÜ„Å†„Åë„ÅÆÈÅì„ÇíÂàá„ÇäÈñã„Åè„ÄÇÊåëÊà¶„Å®ÂãáÊ∞ó„ÅÆÂ≠£ÁØÄ„ÄÇ',
            visual: 'linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%)'
          },
          {
            id: 'love',
            title: 'ÊÑõ',
            subtitle: 'Love',
            color: '#FCE4EC',
            accent: '#E91E63',
            emoji: 'üíï',
            poem: '‰∫å„Å§„ÅÆÈ≠Ç„ÅåÂá∫‰ºö„ÅÜ',
            description: 'Ë™∞„Åã„Å®Ê∑±„ÅèÁπã„Åå„Çä„ÄÅÂøÉ„ÇíÈñã„ÅèÂñú„Å≥„Å®Áóõ„Åø„ÄÇ‰∫∫Áîü„ÇíÂΩ©„ÇãÊúÄ„ÇÇÁæé„Åó„ÅÑÊÑüÊÉÖ„ÄÇ',
            visual: 'radial-gradient(circle at 30% 30%, #FF69B4 0%, #FFB6C1 30%, #FFF0F5 100%)'
          },
          {
            id: 'struggle',
            title: 'Ë©¶Á∑¥',
            subtitle: 'Storm',
            color: '#ECEFF1',
            accent: '#607D8B',
            emoji: 'üåä',
            poem: 'Âµê„ÇíË∂ä„Åà„Å¶',
            description: 'ÊöóÈóò„ÅÆ‰∏≠„ÅßËá™ÂàÜ„Å®Âêë„ÅçÂêà„ÅÜ„ÄÇÂÇ∑„Å§„Åç„Å™„Åå„Çâ„ÇÇ„ÄÅÂº∑„Åï„ÇíË¶ã„Å§„Åë„ÇãÊôÇ„ÄÇ',
            visual: 'linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)'
          },
          {
            id: 'wisdom',
            title: 'ÊàêÁÜü',
            subtitle: 'Harvest',
            color: '#FFF8E1',
            accent: '#FF9800',
            emoji: 'üçÇ',
            poem: 'ÂÆü„Çä„ÅÆÁßã',
            description: 'ÁµåÈ®ì„ÅåÁü•ÊÅµ„Å®„Å™„Çä„ÄÅ‰∫∫Áîü„ÅÆÊ∑±„Åø„ÇíÁêÜËß£„Åô„Çã„ÄÇÁ©è„ÇÑ„Åã„Å™Âº∑„Åï„Å®ÊÖà„Åó„Åø„ÄÇ',
            visual: 'linear-gradient(135deg, #F4A460 0%, #DAA520 50%, #8B4513 100%)'
          },
          {
            id: 'legacy',
            title: 'Á∂ôÊâø',
            subtitle: 'Legacy',
            color: '#F3E5F5',
            accent: '#9C27B0',
            emoji: '‚ú®',
            poem: 'Êòü„Å´„Å™„Çã',
            description: 'Ëá™ÂàÜ„ÅåÊÆã„Åô„ÇÇ„ÅÆ„ÅØ‰Ωï„Åã„ÄÇÊ¨°„ÅÆ‰∏ñ‰ª£„Å∏„Å®Áπã„Åå„Çã„ÄÅÊ∞∏ÈÅ†„ÅÆÁâ©Ë™û„ÄÇ',
            visual: 'radial-gradient(ellipse at 50% 0%, #2c003e 0%, #0d0015 50%, #000 100%)'
          }
        ];

        function LifeJourney() {
          const [activeTab, setActiveTab] = useState(0);
          const [isTransitioning, setIsTransitioning] = useState(false);

          const handleTabChange = (index) => {
            if (index === activeTab || isTransitioning) return;
            setIsTransitioning(true);
            setTimeout(() => {
              setActiveTab(index);
              setIsTransitioning(false);
            }, 300);
          };

          const current = chapters[activeTab];
          const isDark = activeTab === 4 || activeTab === 6;

          return (
            <div style={{
              minHeight: '100vh',
              fontFamily: '"Noto Serif JP", Georgia, serif',
              background: current.visual,
              transition: 'background 0.8s ease-in-out',
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden'
            }}>
              <style>{\`
                @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+JP:wght@300;500;700&family=Zen+Kaku+Gothic+New:wght@300;400&display=swap');
                
                @keyframes float {
                  0%, 100% { transform: translateY(0) rotate(0deg); }
                  50% { transform: translateY(-20px) rotate(5deg); }
                }
                
                @keyframes pulse {
                  0%, 100% { opacity: 0.6; transform: scale(1); }
                  50% { opacity: 1; transform: scale(1.05); }
                }
                
                @keyframes slideUp {
                  from { opacity: 0; transform: translateY(40px); }
                  to { opacity: 1; transform: translateY(0); }
                }
                
                @keyframes starTwinkle {
                  0%, 100% { opacity: 0.3; }
                  50% { opacity: 1; }
                }
                
                .tab-button {
                  position: relative;
                  padding: 12px 8px;
                  background: transparent;
                  border: none;
                  cursor: pointer;
                  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  gap: 6px;
                  opacity: 0.6;
                }
                
                .tab-button:hover {
                  opacity: 1;
                  transform: translateY(-4px);
                }
                
                .tab-button.active {
                  opacity: 1;
                }
                
                .tab-button.active::after {
                  content: '';
                  position: absolute;
                  bottom: 0;
                  left: 50%;
                  transform: translateX(-50%);
                  width: 30px;
                  height: 3px;
                  background: currentColor;
                  border-radius: 2px;
                }
                
                .content-area {
                  flex: 1;
                  display: flex;
                  flex-direction: column;
                  align-items: center;
                  justify-content: center;
                  padding: 40px 20px;
                  position: relative;
                }
                
                .floating-emoji {
                  position: absolute;
                  font-size: 80px;
                  animation: float 6s ease-in-out infinite;
                  opacity: 0.3;
                  filter: blur(2px);
                  z-index: 0;
                }
                
                .main-content {
                  position: relative;
                  z-index: 1;
                  text-align: center;
                  max-width: 600px;
                  animation: slideUp 0.6s ease-out;
                }
                
                .chapter-emoji {
                  font-size: 100px;
                  animation: pulse 3s ease-in-out infinite;
                  margin-bottom: 20px;
                }
                
                .chapter-title {
                  font-size: 4rem;
                  font-weight: 700;
                  letter-spacing: 0.3em;
                  margin: 0;
                  text-shadow: 0 4px 30px rgba(0,0,0,0.1);
                }
                
                .chapter-subtitle {
                  font-family: 'Zen Kaku Gothic New', sans-serif;
                  font-size: 1rem;
                  letter-spacing: 0.5em;
                  text-transform: uppercase;
                  opacity: 0.7;
                  margin-top: 8px;
                }
                
                .chapter-poem {
                  font-size: 1.5rem;
                  font-weight: 300;
                  margin: 30px 0;
                  font-style: italic;
                  opacity: 0.9;
                }
                
                .chapter-description {
                  font-family: 'Zen Kaku Gothic New', sans-serif;
                  font-size: 1.1rem;
                  line-height: 2;
                  opacity: 0.85;
                  max-width: 500px;
                  margin: 0 auto;
                }
                
                .progress-bar {
                  position: absolute;
                  bottom: 0;
                  left: 0;
                  right: 0;
                  height: 4px;
                  background: rgba(255,255,255,0.2);
                }
                
                .progress-fill {
                  height: 100%;
                  transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
                }

                .star {
                  position: absolute;
                  width: 4px;
                  height: 4px;
                  background: white;
                  border-radius: 50%;
                  animation: starTwinkle 2s ease-in-out infinite;
                }
              \`}</style>

              {isDark && Array.from({ length: 30 }).map((_, i) => (
                <div
                  key={i}
                  className="star"
                  style={{
                    left: \`\${Math.random() * 100}%\`,
                    top: \`\${Math.random() * 60}%\`,
                    animationDelay: \`\${Math.random() * 2}s\`,
                    opacity: Math.random() * 0.5 + 0.3
                  }}
                />
              ))}

              <nav style={{
                display: 'flex',
                justifyContent: 'center',
                gap: '8px',
                padding: '30px 20px 20px',
                flexWrap: 'wrap',
                color: isDark ? '#fff' : '#333'
              }}>
                {chapters.map((chapter, index) => (
                  <button
                    key={chapter.id}
                    className={\`tab-button \${activeTab === index ? 'active' : ''}\`}
                    onClick={() => handleTabChange(index)}
                    style={{ color: 'inherit' }}
                  >
                    <span style={{ fontSize: '24px' }}>{chapter.emoji}</span>
                    <span style={{
                      fontSize: '12px',
                      fontFamily: '"Zen Kaku Gothic New", sans-serif',
                      letterSpacing: '0.1em'
                    }}>
                      {chapter.title}
                    </span>
                  </button>
                ))}
              </nav>

              <main className="content-area" style={{
                color: isDark ? '#fff' : '#333',
                opacity: isTransitioning ? 0 : 1,
                transition: 'opacity 0.3s ease'
              }}>
                <span className="floating-emoji" style={{ top: '10%', left: '5%', animationDelay: '0s' }}>
                  {current.emoji}
                </span>
                <span className="floating-emoji" style={{ top: '60%', right: '10%', animationDelay: '2s' }}>
                  {current.emoji}
                </span>
                <span className="floating-emoji" style={{ bottom: '20%', left: '15%', animationDelay: '4s' }}>
                  {current.emoji}
                </span>

                <div className="main-content" key={activeTab}>
                  <div className="chapter-emoji">{current.emoji}</div>
                  <h1 className="chapter-title">{current.title}</h1>
                  <p className="chapter-subtitle">{current.subtitle}</p>
                  <p className="chapter-poem">„Äå{current.poem}„Äç</p>
                  <p className="chapter-description">{current.description}</p>
                </div>
              </main>

              <div className="progress-bar">
                <div 
                  className="progress-fill"
                  style={{
                    width: \`\${((activeTab + 1) / chapters.length) * 100}%\`,
                    background: current.accent
                  }}
                />
              </div>

              <div style={{
                position: 'absolute',
                bottom: '20px',
                right: '20px',
                fontFamily: '"Zen Kaku Gothic New", sans-serif',
                fontSize: '14px',
                opacity: 0.6,
                color: isDark ? '#fff' : '#333'
              }}>
                {String(activeTab + 1).padStart(2, '0')} / {String(chapters.length).padStart(2, '0')}
              </div>
            </div>
          );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<LifeJourney />);
    <\/script>
</body>
</html>`;

        // Launch game function
        function launchGame(type) {
            const container = document.getElementById(type + 'Container');
            const frame = document.getElementById(type + 'Frame');
            
            frame.srcdoc = gameContent[type];
            container.classList.add('active');
        }

        // Close game function
        function closeGame(type) {
            const container = document.getElementById(type + 'Container');
            const frame = document.getElementById(type + 'Frame');
            
            container.classList.remove('active');
            setTimeout(() => {
                frame.srcdoc = '';
            }, 300);
        }
    </script>
</body>
</html>
